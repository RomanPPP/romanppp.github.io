{"version":3,"file":"bundle.js","sources":["webpack:///webpack/bootstrap","webpack:///./src/game/entity.js","webpack:///./src/game/objects.js","webpack:///./src/m3.js","webpack:///./src/m4.js","webpack:///./src/main.js","webpack:///./src/node.js","webpack:///./src/render/basemodel.js","webpack:///./src/render/model.js","webpack:///./src/render/primitives.js","webpack:///./src/render/programm.js","webpack:///./src/render/render.js","webpack:///./src/render/sprites.js","webpack:///./src/server/collider.js","webpack:///./src/server/constraints.js","webpack:///./src/server/eventEmitter.js","webpack:///./src/server/gjk.js","webpack:///./src/server/physics.js","webpack:///./src/server/simulation.js","webpack:///./src/server/tree.js","webpack:///./src/server/vectors.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/main.js\");\n","\r\nconst {Node, TRS } = require('../node')\r\nconst {Physics} = require('../server/physics')\r\nconst {Box} = require('../server/collider')\r\nconst {makeRenderNode} = require('../render/model')\r\nconst {cube} = require('../render/basemodel')\r\nconst m4 = require('../m4')\r\nconst PartsMap = {\r\n    box : function(x,y,z){\r\n        return new Physics(new Box(x,y,z))\r\n    }\r\n}\r\nconst modelMap = {\r\n    box : function(){\r\n        return makeRenderNode(cube)\r\n    }\r\n}\r\n\r\nclass EntityNode extends Node{\r\n    constructor(localMatrix, name, source, physics, renderNode){\r\n        super(localMatrix, name, source)\r\n        this.physics = physics\r\n        this.renderNode = renderNode\r\n        this.objectsToDraw = []\r\n    }\r\n    updateWorldMatrix(parentWorldMatrix){\r\n        if(!parentWorldMatrix){\r\n            this.worldMatrix = this.physics.collider.getM4()\r\n            this.renderNode.updateWorldMatrix(this.worldMatrix)\r\n            this.children.forEach(child => child.updateWorldMatrix(this.worldMatrix))\r\n            return\r\n        }\r\n        let matrix = this.source.getMatrix()\r\n        matrix = m4.multiply(parentWorldMatrix, matrix);\r\n        this.worldMatrix = m4.multiply(matrix, this.localMatrix)\r\n        this.physics.collider.pos.x = this.worldMatrix[12]\r\n        this.physics.collider.pos.x = this.worldMatrix[13]\r\n        this.physics.collider.pos.x = this.worldMatrix[14]\r\n        this.physics.collider.setRmatrix(m4.m4Tom3(this.worldMatrix))\r\n        this.renderNode.updateWorldMatrix(this.worldMatrix)\r\n        this.children.forEach((child) => {\r\n            child.updateWorldMatrix([...matrix]);\r\n        })\r\n    }\r\n    updateObjectsToDraw(){\r\n        this.traversal(node =>{\r\n            \r\n            if(node.renderNode){\r\n                node.renderNode.traversal(_node =>this.objectsToDraw.push(_node))\r\n                \r\n            }\r\n        })\r\n    }\r\n}\r\nconst makeEntity = (desc) =>{\r\n    const source = new TRS()\r\n    let matrix = m4.xRotation(desc.rotation[0])\r\n    matrix = m4.yRotate(matrix,desc.rotation[1])\r\n    matrix = m4.zRotate(matrix,desc.rotation[2])\r\n    matrix = m4.translate(matrix,...desc.translation)\r\n    const physics = PartsMap[desc.physics.name](...desc.physics.props)\r\n    const model = modelMap[desc.model.name](...desc.model.props)\r\n    const node = new EntityNode(matrix, desc.name, source, physics, model)\r\n    \r\n    if(desc.children){\r\n        desc.children.forEach(childDesc =>{\r\n            const child = makeEntity(childDesc)\r\n            child.setParent(node)\r\n        })\r\n    }\r\n    return node\r\n}\r\nmodule.exports = { EntityNode, makeEntity}\r\n","\r\nconst box = {\r\n    translation : [0,0,0],\r\n    rotation :  [0,0,0],\r\n    scale : [1,1,1],\r\n    physics : {\r\n        name : 'box',\r\n        props : [1,1,1]\r\n    },\r\n    model : {\r\n        name : 'box',\r\n        props : []\r\n    },\r\n    \r\n}\r\n\r\nmodule.exports = {box}","const m3 = {\r\n    multiply : function(b, a) {\r\n        var a00 = a[0 * 3 + 0];\r\n        var a01 = a[0 * 3 + 1];\r\n        var a02 = a[0 * 3 + 2];\r\n        var a10 = a[1 * 3 + 0];\r\n        var a11 = a[1 * 3 + 1];\r\n        var a12 = a[1 * 3 + 2];\r\n        var a20 = a[2 * 3 + 0];\r\n        var a21 = a[2 * 3 + 1];\r\n        var a22 = a[2 * 3 + 2];\r\n        var b00 = b[0 * 3 + 0];\r\n        var b01 = b[0 * 3 + 1];\r\n        var b02 = b[0 * 3 + 2];\r\n        var b10 = b[1 * 3 + 0];\r\n        var b11 = b[1 * 3 + 1];\r\n        var b12 = b[1 * 3 + 2];\r\n        var b20 = b[2 * 3 + 0];\r\n        var b21 = b[2 * 3 + 1];\r\n        var b22 = b[2 * 3 + 2];\r\n    \r\n        return [\r\n          b00 * a00 + b01 * a10 + b02 * a20,\r\n          b00 * a01 + b01 * a11 + b02 * a21,\r\n          b00 * a02 + b01 * a12 + b02 * a22,\r\n          b10 * a00 + b11 * a10 + b12 * a20,\r\n          b10 * a01 + b11 * a11 + b12 * a21,\r\n          b10 * a02 + b11 * a12 + b12 * a22,\r\n          b20 * a00 + b21 * a10 + b22 * a20,\r\n          b20 * a01 + b21 * a11 + b22 * a21,\r\n          b20 * a02 + b21 * a12 + b22 * a22,\r\n        ];\r\n      },\r\n      xRotation: function(angleInRadians) {\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n     \r\n        return [\r\n          1, 0, 0, \r\n          0, c, s, \r\n          0, -s, c\r\n        ];\r\n      },\r\n     \r\n      yRotation: function(angleInRadians) {\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n     \r\n        return [\r\n          c, 0, -s, \r\n          0, 1, 0, \r\n          s, 0, c\r\n        ];\r\n      },\r\n     \r\n      zRotation: function(angleInRadians) {\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n     \r\n        return [\r\n           c, s, 0, \r\n          -s, c, 0,\r\n           0, 0, 1\r\n        ];\r\n      },\r\n      m3Tom4 : function(m){\r\n        const dst = new Float32Array(16)\r\n        dst[ 0] = m[0]\r\n        dst[ 1] = m[1]\r\n        dst[ 2] = m[2]\r\n        dst[ 3] = 0\r\n        dst[ 4] = m[3]\r\n        dst[ 5] = m[4]\r\n        dst[ 6] = m[5]\r\n        dst[ 7] = 0\r\n        dst[ 8] = m[6]\r\n        dst[ 9] = m[7]\r\n        dst[10] = m[8]\r\n        dst[11] = 0\r\n        dst[12] = 0\r\n        dst[13] = 0\r\n        dst[14] = 0\r\n        dst[15] = 1\r\n        return dst\r\n      },\r\n      xRotate: function(m, angleInRadians) {\r\n        return m3.multiply(m, m3.xRotation(angleInRadians));\r\n      },\r\n     \r\n      yRotate: function(m, angleInRadians) {\r\n        return m3.multiply(m, m3.yRotation(angleInRadians));\r\n      },\r\n     \r\n      zRotate: function(m, angleInRadians) {\r\n        return m3.multiply(m, m3.zRotation(angleInRadians));\r\n      },\r\n      transformPoint : function(m, v, dst) {\r\n        dst = dst || new Float32Array(3);\r\n        var v0 = v[0];\r\n        var v1 = v[1];\r\n        var v2 = v[2];\r\n        \r\n    \r\n        dst[0] = (v0 * m[0 * 3 + 0] + v1 * m[1 * 3 + 0] + v2 * m[2 * 3 + 0]  ) \r\n        dst[1] = (v0 * m[0 * 3 + 1] + v1 * m[1 * 3 + 1] + v2 * m[2 * 3 + 1]  ) \r\n        dst[2] = (v0 * m[0 * 3 + 2] + v1 * m[1 * 3 + 2] + v2 * m[2 * 3 + 2] ) \r\n    \r\n        return dst;\r\n      },\r\n      identity : function() {\r\n        return [\r\n          1, 0, 0,\r\n          0, 1, 0,\r\n          0, 0, 1,\r\n        ];\r\n      },\r\n      transpose : function(m){\r\n         \r\n          dst = new Float32Array(9)\r\n          dst[0] = m[0]\r\n          dst[1] = m[3]\r\n          dst[2] = m[6]\r\n          dst[3] = m[1]\r\n          dst[4] = m[4]\r\n          dst[5] = m[7]\r\n          dst[6] = m[2]\r\n          dst[7] = m[5]\r\n          dst[8] = m[8]\r\n          return dst\r\n      },\r\n      scaling : function(sx,sy,sz){\r\n        return new Float32Array([\r\n                    sx, 0, 0,\r\n                    0, sy, 0,\r\n                    0,  0, sz\r\n              ])\r\n      },\r\n      scale : function(m, sx,sy,sz){\r\n        return m3.multiply(m, m3.scaling(sx, sy, sz))\r\n      },\r\n      inverse : function(m){\r\n       const det = m[0] * m[4] * m[8] + \r\n                   m[2] * m[3] * m[7] +\r\n                   m[1] * m[5] * m[6] -\r\n                   m[2] * m[4] * m[6] -\r\n                   m[0] * m[5] * m[7] -\r\n                   m[8] * m[3] * m[2] \r\n        const dst = new Float32Array(9)\r\n        dst[0] = (m[4] * m[8] - m[7] * m[5]) / det\r\n        dst[1] = (m[3] * m[8] - m[6] * m[5]) / det\r\n        dst[2] = (m[3] * m[7] - m[6] * m[4]) / det\r\n        dst[3] = (m[1] * m[8] - m[2] * m[7]) / det\r\n        dst[4] = (m[3])\r\n        \r\n      },\r\n      toString(m){\r\n        return m.reduce((acc,el,idx) => (idx) % 3 === 0 ? acc += '\\n' + el : acc += ' ' + el )\r\n      },\r\n      dot(v1,v2){\r\n        return v1[0]*v2[0] + v1[1]*v2[1] + v1[2] * v2[2]\r\n      }\r\n}\r\nmodule.exports = m3","const MatType = Float32Array\r\nconst m4 = {\r\n    multiply: function(a, b) {\r\n      var a00 = a[0 * 4 + 0];\r\n      var a01 = a[0 * 4 + 1];\r\n      var a02 = a[0 * 4 + 2];\r\n      var a03 = a[0 * 4 + 3];\r\n      var a10 = a[1 * 4 + 0];\r\n      var a11 = a[1 * 4 + 1];\r\n      var a12 = a[1 * 4 + 2];\r\n      var a13 = a[1 * 4 + 3];\r\n      var a20 = a[2 * 4 + 0];\r\n      var a21 = a[2 * 4 + 1];\r\n      var a22 = a[2 * 4 + 2];\r\n      var a23 = a[2 * 4 + 3];\r\n      var a30 = a[3 * 4 + 0];\r\n      var a31 = a[3 * 4 + 1];\r\n      var a32 = a[3 * 4 + 2];\r\n      var a33 = a[3 * 4 + 3];\r\n      var b00 = b[0 * 4 + 0];\r\n      var b01 = b[0 * 4 + 1];\r\n      var b02 = b[0 * 4 + 2];\r\n      var b03 = b[0 * 4 + 3];\r\n      var b10 = b[1 * 4 + 0];\r\n      var b11 = b[1 * 4 + 1];\r\n      var b12 = b[1 * 4 + 2];\r\n      var b13 = b[1 * 4 + 3];\r\n      var b20 = b[2 * 4 + 0];\r\n      var b21 = b[2 * 4 + 1];\r\n      var b22 = b[2 * 4 + 2];\r\n      var b23 = b[2 * 4 + 3];\r\n      var b30 = b[3 * 4 + 0];\r\n      var b31 = b[3 * 4 + 1];\r\n      var b32 = b[3 * 4 + 2];\r\n      var b33 = b[3 * 4 + 3];\r\n      return [\r\n        b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,\r\n        b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,\r\n        b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,\r\n        b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,\r\n        b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,\r\n        b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,\r\n        b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,\r\n        b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,\r\n        b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,\r\n        b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,\r\n        b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,\r\n        b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,\r\n        b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,\r\n        b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,\r\n        b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,\r\n        b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33,\r\n      ];\r\n    },\r\n      \r\n      translation: function(tx, ty, tz) {\r\n        return [\r\n           1,  0,  0,  0,\r\n           0,  1,  0,  0,\r\n           0,  0,  1,  0,\r\n           tx, ty, tz, 1,\r\n        ];\r\n      },\r\n     \r\n      xRotation: function(angleInRadians) {\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n     \r\n        return [\r\n          1, 0, 0, 0,\r\n          0, c, s, 0,\r\n          0, -s, c, 0,\r\n          0, 0, 0, 1,\r\n        ];\r\n      },\r\n     \r\n      yRotation: function(angleInRadians) {\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n     \r\n        return [\r\n          c, 0, -s, 0,\r\n          0, 1, 0, 0,\r\n          s, 0, c, 0,\r\n          0, 0, 0, 1,\r\n        ];\r\n      },\r\n     \r\n      zRotation: function(angleInRadians) {\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n     \r\n        return [\r\n           c, s, 0, 0,\r\n          -s, c, 0, 0,\r\n           0, 0, 1, 0,\r\n           0, 0, 0, 1,\r\n        ];\r\n      },\r\n     \r\n      scaling: function(sx, sy, sz) {\r\n        return [\r\n          sx, 0,  0,  0,\r\n          0, sy,  0,  0,\r\n          0,  0, sz,  0,\r\n          0,  0,  0,  1,\r\n        ];\r\n      },\r\n      translate: function(m, tx, ty, tz) {\r\n        return m4.multiply(m, m4.translation(tx, ty, tz));\r\n      },\r\n     \r\n      xRotate: function(m, angleInRadians) {\r\n        return m4.multiply(m, m4.xRotation(angleInRadians));\r\n      },\r\n     \r\n      yRotate: function(m, angleInRadians) {\r\n        return m4.multiply(m, m4.yRotation(angleInRadians));\r\n      },\r\n     \r\n      zRotate: function(m, angleInRadians) {\r\n        return m4.multiply(m, m4.zRotation(angleInRadians));\r\n      },\r\n     \r\n      scale: function(m, sx, sy, sz) {\r\n        return m4.multiply(m, m4.scaling(sx, sy, sz));\r\n      },\r\n      makeOrt : function(v){\r\n        const o = [0,0,0]\r\n        const norm = Math.sqrt( v[0] * v[0] + v[1] * v[1] + v[2]*v[2] )\r\n        o[0] = v[0] / norm\r\n        o[1] = v[1] / norm\r\n        o[2] = v[2] / norm\r\n        return o\r\n      },\r\n      projection: function(width, height, depth) {\r\n        // Эта матрица переворачивает Y, чтобы 0 был наверху\r\n        return [\r\n           2 / width, 0, 0, 0,\r\n           0, -2 / height, 0, 0,\r\n           0, 0, 2 / depth, 0,\r\n          -1, 1, 0, 1,\r\n        ];\r\n      },\r\n      perspective: function(fieldOfViewInRadians, aspect, near, far) {\r\n        var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);\r\n        var rangeInv = 1.0 / (near - far);\r\n     \r\n        return [\r\n          f / aspect, 0, 0, 0,\r\n          0, f, 0, 0,\r\n          0, 0, (near + far) * rangeInv, -1,\r\n          0, 0, near * far * rangeInv * 2, 0\r\n        ];\r\n      },\r\n      inverse: function(m) {\r\n        var m00 = m[0 * 4 + 0];\r\n        var m01 = m[0 * 4 + 1];\r\n        var m02 = m[0 * 4 + 2];\r\n        var m03 = m[0 * 4 + 3];\r\n        var m10 = m[1 * 4 + 0];\r\n        var m11 = m[1 * 4 + 1];\r\n        var m12 = m[1 * 4 + 2];\r\n        var m13 = m[1 * 4 + 3];\r\n        var m20 = m[2 * 4 + 0];\r\n        var m21 = m[2 * 4 + 1];\r\n        var m22 = m[2 * 4 + 2];\r\n        var m23 = m[2 * 4 + 3];\r\n        var m30 = m[3 * 4 + 0];\r\n        var m31 = m[3 * 4 + 1];\r\n        var m32 = m[3 * 4 + 2];\r\n        var m33 = m[3 * 4 + 3];\r\n        var tmp_0  = m22 * m33;\r\n        var tmp_1  = m32 * m23;\r\n        var tmp_2  = m12 * m33;\r\n        var tmp_3  = m32 * m13;\r\n        var tmp_4  = m12 * m23;\r\n        var tmp_5  = m22 * m13;\r\n        var tmp_6  = m02 * m33;\r\n        var tmp_7  = m32 * m03;\r\n        var tmp_8  = m02 * m23;\r\n        var tmp_9  = m22 * m03;\r\n        var tmp_10 = m02 * m13;\r\n        var tmp_11 = m12 * m03;\r\n        var tmp_12 = m20 * m31;\r\n        var tmp_13 = m30 * m21;\r\n        var tmp_14 = m10 * m31;\r\n        var tmp_15 = m30 * m11;\r\n        var tmp_16 = m10 * m21;\r\n        var tmp_17 = m20 * m11;\r\n        var tmp_18 = m00 * m31;\r\n        var tmp_19 = m30 * m01;\r\n        var tmp_20 = m00 * m21;\r\n        var tmp_21 = m20 * m01;\r\n        var tmp_22 = m00 * m11;\r\n        var tmp_23 = m10 * m01;\r\n    \r\n        var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -\r\n            (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\r\n        var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -\r\n            (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\r\n        var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -\r\n            (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\r\n        var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -\r\n            (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\r\n    \r\n        var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\r\n    \r\n        return [\r\n          d * t0,\r\n          d * t1,\r\n          d * t2,\r\n          d * t3,\r\n          d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -\r\n                (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30)),\r\n          d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -\r\n                (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30)),\r\n          d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -\r\n                (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30)),\r\n          d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -\r\n                (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20)),\r\n          d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -\r\n                (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33)),\r\n          d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -\r\n                (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33)),\r\n          d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -\r\n                (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33)),\r\n          d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -\r\n                (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23)),\r\n          d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -\r\n                (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22)),\r\n          d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -\r\n                (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02)),\r\n          d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -\r\n                (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12)),\r\n          d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -\r\n                (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02))\r\n        ];\r\n      },\r\n      lookAt: function(cameraPosition, target, up) {\r\n        var zAxis = normalize(\r\n            subtractVectors(cameraPosition, target));\r\n        var xAxis = normalize(cross(up, zAxis));\r\n        var yAxis = normalize(cross(zAxis, xAxis));\r\n     \r\n        return [\r\n           xAxis[0], xAxis[1], xAxis[2], 0,\r\n           yAxis[0], yAxis[1], yAxis[2], 0,\r\n           zAxis[0], zAxis[1], zAxis[2], 0,\r\n           cameraPosition[0],\r\n           cameraPosition[1],\r\n           cameraPosition[2],\r\n           1,\r\n        ];\r\n      },\r\n      copy:function(src){\r\n        \r\n          const dst = new MatType(16);\r\n      \r\n          dst[ 0] = src[ 0];\r\n          dst[ 1] = src[ 1];\r\n          dst[ 2] = src[ 2];\r\n          dst[ 3] = src[ 3];\r\n          dst[ 4] = src[ 4];\r\n          dst[ 5] = src[ 5];\r\n          dst[ 6] = src[ 6];\r\n          dst[ 7] = src[ 7];\r\n          dst[ 8] = src[ 8];\r\n          dst[ 9] = src[ 9];\r\n          dst[10] = src[10];\r\n          dst[11] = src[11];\r\n          dst[12] = src[12];\r\n          dst[13] = src[13];\r\n          dst[14] = src[14];\r\n          dst[15] = src[15];\r\n      \r\n          return dst;\r\n        \r\n      \r\n      },\r\n      vectorSum : function(v1,v2){\r\n        const vector = [0,0,0]\r\n        vector[0] = v1[0] + v2[0]\r\n        vector[1] = v1[1] + v2[1]\r\n        vector[2] = v1[2] + v2[2]\r\n        return vector\r\n      },\r\n      cross  : function(a, b) {\r\n        return [a[1] * b[2] - a[2] * b[1],\r\n                a[2] * b[0] - a[0] * b[2],\r\n                a[0] * b[1] - a[1] * b[0]];\r\n      },\r\n      vectorScalarProduct(a,s){\r\n        let v = [0,0,0]\r\n\r\n        v[0] = a[0] * s\r\n        v[1] = a[1] * s\r\n        v[2] = a[2] * s\r\n        if(isNaN(v[0])|| isNaN(v[2]) || isNaN(v[2])) return [0,0,0]\r\n        return v\r\n      },\r\n\r\n      scalarProduct : function(v1,v2){\r\n        let a = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]\r\n        \r\n        return a\r\n      },\r\n      dot(v1,v2){\r\n        return v1[0]*v2[0] + v1[1]*v2[1] + v1[2] * v2[2]\r\n      },\r\n      isNullVector: function(v){\r\n        \r\n        return !v[0]&&!v[1]&&!v[2]\r\n      },\r\n      getVectorLength(v){\r\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2])\r\n      },\r\n      transformPoint : function(m, v, dst) {\r\n        dst = dst || new MatType(3);\r\n        var v0 = v[0];\r\n        var v1 = v[1];\r\n        var v2 = v[2];\r\n        var d = v0 * m[0 * 4 + 3] + v1 * m[1 * 4 + 3] + v2 * m[2 * 4 + 3] + m[3 * 4 + 3];\r\n    \r\n        dst[0] = (v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0] + m[3 * 4 + 0]) / d;\r\n        dst[1] = (v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1] + m[3 * 4 + 1]) / d;\r\n        dst[2] = (v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2] + m[3 * 4 + 2]) / d;\r\n    \r\n        return dst;\r\n      },\r\n      normalize : function(v, dst) {\r\n        dst = dst || new MatType(3);\r\n        var length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\r\n        // make sure we don't divide by 0.\r\n        if (length > 0.00001) {\r\n          dst[0] = v[0] / length;\r\n          dst[1] = v[1] / length;\r\n          dst[2] = v[2] / length;\r\n        }\r\n        return dst;\r\n      },\r\n      identity: function() {\r\n        dst = new MatType(16);\r\n        dst[ 0] = 1;\r\n        dst[ 1] = 0;\r\n        dst[ 2] = 0;\r\n        dst[ 3] = 0;\r\n        dst[ 4] = 0;\r\n        dst[ 5] = 1;\r\n        dst[ 6] = 0;\r\n        dst[ 7] = 0;\r\n        dst[ 8] = 0;\r\n        dst[ 9] = 0;\r\n        dst[10] = 1;\r\n        dst[11] = 0;\r\n        dst[12] = 0;\r\n        dst[13] = 0;\r\n        dst[14] = 0;\r\n        dst[15] = 1;\r\n    \r\n        return dst;\r\n      },\r\n      m3Tom4 : function(m){\r\n        const dst = new MatType(16)\r\n        dst[ 0] = m[0]\r\n        dst[ 1] = m[1]\r\n        dst[ 2] = m[2]\r\n        dst[ 3] = 0\r\n        dst[ 4] = m[3]\r\n        dst[ 5] = m[4]\r\n        dst[ 6] = m[5]\r\n        dst[ 7] = 0\r\n        dst[ 8] = m[6]\r\n        dst[ 9] = m[7]\r\n        dst[10] = m[8]\r\n        dst[11] = 0\r\n        dst[12] = 0\r\n        dst[13] = 0\r\n        dst[14] = 0\r\n        dst[15] = 1\r\n        return dst\r\n      },\r\n      m4Tom3 : function(m){\r\n        const dst = new MatType(9)\r\n        dst[ 0] = m[0]\r\n        dst[ 1] = m[1]\r\n        dst[ 2] = m[2]\r\n        dst[ 3] = m[4]\r\n        dst[ 4] = m[5]\r\n        dst[ 5] = m[6]\r\n        dst[ 6] = m[8]\r\n        dst[ 7] = m[9]\r\n        dst[ 8] = m[10]\r\n        return dst\r\n      },\r\n      toString(m){\r\n        return m.reduce((acc,el,idx) => (idx) % 4 === 0 ? acc += '\\n' + el : acc += ' ' + el )\r\n      },\r\n      transpose: function(m) {\r\n        return [\r\n          m[0], m[4], m[8], m[12],\r\n          m[1], m[5], m[9], m[13],\r\n          m[2], m[6], m[10], m[14],\r\n          m[3], m[7], m[11], m[15],\r\n        ];\r\n      },\r\n    };\r\n    function makeZToWMatrix(fudgeFactor) {\r\n      return [\r\n        1, 0, 0, 0,\r\n        0, 1, 0, 0,\r\n        0, 0, 1, fudgeFactor,\r\n        0, 0, 0, 1,\r\n      ];\r\n    }\r\n    function cross(a, b) {\r\n      return [a[1] * b[2] - a[2] * b[1],\r\n              a[2] * b[0] - a[0] * b[2],\r\n              a[0] * b[1] - a[1] * b[0]];\r\n    }\r\n    function subtractVectors(a, b) {\r\n      return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];\r\n    }\r\n    \r\nmodule.exports = m4","const {drawScene, drawPoints, drawLines, resizeCanvasToDisplaySize} = require('./render/render')\r\nconst m4 = require('./m4')\r\n\r\nconst {makeEntity} = require('./game/entity')\r\nconst {box} = require('./game/objects')\r\n\r\nconst cPos = [0,2,25]\r\nconst cRot = [0,0,0]\r\nconst controls = {\r\n    ArrowDown : ()=> cRot[0] -= 0.1 ,\r\n    ArrowUp : () => cRot[0] += 0.1 ,\r\n    ArrowLeft : () => cRot[1] += 0.1,\r\n    ArrowRight : () => cRot[1] -=0.1 ,\r\n    w : () => {\r\n        const delta = m4.transformPoint(m4.xRotate(m4.yRotation(cRot[1]), cRot[0]),[0,0,-1])\r\n        cPos[0] += delta[0]\r\n        cPos[1] += delta[1]\r\n        cPos[2] += delta[2]\r\n        \r\n    } ,\r\n    s : () => {\r\n        const delta = m4.transformPoint(m4.xRotate(m4.yRotation(cRot[1]), cRot[0]),[0,0,1])\r\n        cPos[0] += delta[0]\r\n        cPos[1] += delta[1]\r\n        cPos[2] += delta[2]\r\n        \r\n    } ,\r\n    a : () => {\r\n        const delta = m4.transformPoint(m4.xRotate(m4.yRotation(cRot[1]), cRot[0]),[-1,0,0])\r\n        cPos[0] += delta[0]\r\n        cPos[1] += delta[1]\r\n        cPos[2] += delta[2]\r\n        \r\n    } ,\r\n    d : () => {\r\n        const delta = m4.transformPoint(m4.xRotate(m4.yRotation(cRot[1]), cRot[0]),[1,0,0])\r\n        cPos[0] += delta[0]\r\n        cPos[1] += delta[1]\r\n        cPos[2] += delta[2]\r\n        \r\n    }\r\n}\r\nconst mouseControls = {\r\n    lastX : 0,\r\n    lastY : 0,\r\n    mousemove : function(e){\r\n        \r\n        deltaX = e.offsetX - this.lastX \r\n        this.lastX = e.offsetX\r\n        deltaY = e.offsetY -  this.lastY\r\n        this.lastY = e.offsetY\r\n        \r\n        cRot[1] -= deltaX*0.005\r\n        cRot[0] -= deltaY*0.005\r\n    }\r\n}\r\ndocument.onkeydown = e =>{\r\n    if(!controls[e.key]) return\r\n    controls[e.key]()\r\n}\r\ndocument.onmousedown = (e) =>{\r\n    mouseControls.lastY = e.offsetY\r\n    mouseControls.lastX = e.offsetX\r\n    document.onmousemove = mouseControls.mousemove.bind(mouseControls)\r\n    document.onmouseup = ()=>{\r\n       \r\n        document.onmousemove = null\r\n    }\r\n}\r\nconst uniforms = { u_lightWorldPosition : [0,35,0], u_ambientLight : [0.2,0.2,0.3,1]}\r\nconst {Simulation} = require('./server/simulation')\r\nconst sim = new Simulation()\r\n\r\n\r\n\r\nconst { Vector } = require('./server/vectors')\r\nconst objectsToDraw = []\r\nconst floor = makeEntity(box)\r\nconst floor2 = makeEntity(box)\r\nconst wallN = makeEntity(box)\r\nconst wallS = makeEntity(box)\r\nconst wallW = makeEntity(box)\r\nconst wallE = makeEntity(box)\r\n\r\n\r\nfloor.updateObjectsToDraw()\r\nsim.addObject(floor.physics)\r\nfloor.physics.collider.min = new Vector(-30,-2,-30)\r\nfloor.physics.collider.max = new Vector(30,2,30)\r\n\r\n\r\nfloor.renderNode.localMatrix = m4.scaling(60,4,60)\r\nfloor.physics.setMass(100000000)\r\n\r\nfloor2.updateObjectsToDraw()\r\nsim.addObject(floor2.physics)\r\nfloor2.physics.collider.min = new Vector(-10,-10,-10)\r\nfloor2.physics.collider.max = new Vector(10,10,10)\r\nfloor2.renderNode.localMatrix = m4.scaling(20,20,20)\r\nfloor2.physics.setMass(100000000)\r\n\r\nlet entities = [wallN, wallE, wallW, wallS]\r\nentities.forEach(wall =>{\r\n    wall.updateObjectsToDraw()\r\n    objectsToDraw.push(...wall.objectsToDraw)\r\n    sim.addObject(wall.physics)\r\n    wall.physics.setMass(100000000)\r\n    wall.physics.static = true\r\n    wall.physics.collider.min = new Vector(-30,-2,-30)\r\n    wall.physics.collider.max = new Vector(30,2,30)\r\n    wall.renderNode.localMatrix = m4.scaling(60,4,60)\r\n})\r\nentities.push(floor, floor2)\r\nfloor.physics.translate(0,-2,0)\r\nfloor.physics.static = true\r\nfloor2.physics.static = true\r\n\r\nfloor2.physics.translate(10,0,0)\r\nfloor2.physics.rotate(Math.PI/4,0,0)\r\nwallN.physics.translate(0,0,30)\r\nwallN.physics.rotate(Math.PI/2,0,0)\r\n\r\nwallS.physics.translate(0,0,-30)\r\nwallS.physics.rotate(Math.PI/2,0,0)\r\n\r\nwallW.physics.translate(30,0,0)\r\nwallW.physics.rotate(0,0, Math.PI/2)\r\n\r\nwallE.physics.translate(-30,0,0)\r\nwallE.physics.rotate(0,0, Math.PI/2)\r\n\r\n\r\nobjectsToDraw.push(...floor.objectsToDraw, ...floor2.objectsToDraw)\r\n\r\nlet cameraMatrix = m4.translation(...cPos)\r\ncameraMatrix = m4.yRotate(cameraMatrix, cRot[1])\r\ncameraMatrix = m4.xRotate(cameraMatrix, cRot[0])\r\n\r\n\r\n\r\n\r\ncontrols[' '] = () =>{\r\n    const cube = makeEntity(box)\r\n    cube.updateObjectsToDraw()\r\n    entities.push(cube)\r\n    objectsToDraw.push(...cube.objectsToDraw)\r\n    sim.addObject(cube.physics)\r\n    \r\n    cube.renderNode.sprite.uniforms.u_color = [0.2,0.3,0.4,1]\r\n    cube.physics.translate(...cPos)\r\n    \r\n    let Rm = m4.yRotation(cRot[1])\r\n    Rm = m4.xRotate(Rm, cRot[0])\r\n    \r\n    const vel = m4.transformPoint(Rm, [0,0,-20])\r\n    \r\n    cube.physics.addVelocity(new Vector(...vel))\r\n    cube.physics.addAcceleration(new Vector(0,-9.8,0))\r\n    \r\n\r\n}\r\n \r\nresizeCanvasToDisplaySize(gl.canvas, 1)\r\n\r\nconst loop = () =>{\r\n    \r\n   \r\n    \r\n    entities.forEach(entity => entity.updateWorldMatrix())\r\n    sim.tick(0.016)\r\n    cameraMatrix = m4.translation(...cPos)\r\n    cameraMatrix = m4.yRotate(cameraMatrix, cRot[1])\r\n    cameraMatrix = m4.xRotate(cameraMatrix, cRot[0])\r\n    \r\n    const manifolds = sim.collisionManifolds.values()\r\n    const cols = []\r\n    for(let manifold of manifolds)cols.push(...manifold.contacts)\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n    gl.enable(gl.CULL_FACE)\r\n    gl.enable(gl.DEPTH_TEST)\r\n    drawScene(objectsToDraw, cameraMatrix, uniforms)\r\n   \r\n    requestAnimationFrame(loop)\r\n\r\n\r\n}\r\n\r\nloop()","\r\nconst m4 = require('./m4')\r\nclass TRS{\r\n    constructor(){\r\n        this.translation = [0,0,0]\r\n        this.rotation = [0, 0, 0]\r\n        this.scale = [1, 1, 1]\r\n    }\r\n    \r\n    getMatrix(m) {\r\n        let dst = m || m4.identity();\r\n        var t = this.translation;\r\n        var r = this.rotation;\r\n        var s = this.scale;\r\n        dst = m4.translate(dst,t[0], t[1], t[2]);\r\n        dst = m4.xRotate(dst, r[0]);\r\n        dst = m4.yRotate(dst, r[1]);\r\n        dst = m4.zRotate(dst, r[2]);\r\n        dst = m4.scale(dst, s[0], s[1], s[2]);\r\n        return dst;\r\n      };\r\n    getRMatrix(){\r\n        let dst = m4.identity();\r\n        var r = this.rotation;\r\n        dst = m4.xRotate(dst, r[0]);\r\n        dst = m4.yRotate(dst, r[1]);\r\n        dst = m4.zRotate(dst, r[2]);\r\n        return dst\r\n    }\r\n}\r\nclass Node{\r\n    constructor(localMatrix, name, source = new TRS()){\r\n        this.localMatrix = localMatrix\r\n        this.worldMatrix = m4.identity()\r\n        this.parent = null\r\n        this.children = []\r\n        this.source = source\r\n        this.name = name\r\n        this.parts = []\r\n    }\r\n    setParent(parent){\r\n        if (this.parent) {\r\n            var ndx = this.parent.children.indexOf(this);\r\n            if (ndx >= 0) {\r\n              this.parent.children.splice(ndx, 1);\r\n            }\r\n          }\r\n          if (parent) {\r\n            parent.children.push(this);\r\n          }\r\n          this.parent = parent;\r\n    }\r\n    updateWorldMatrix(parentWorldMatrix){\r\n        var source = this.source;\r\n        let matrix = source.getMatrix()\r\n        if (parentWorldMatrix) {\r\n          matrix = m4.multiply(parentWorldMatrix, matrix);\r\n        }\r\n        this.worldMatrix = m4.multiply(matrix, this.localMatrix)\r\n        this.children.forEach((child) => {\r\n          child.updateWorldMatrix([...matrix]);\r\n        })\r\n    }\r\n    updatePartsList(){\r\n        const iter = (node,arr) => {\r\n            arr.push(node)\r\n            node.children.forEach(child => iter(child,arr))\r\n        }\r\n        iter(this, this.parts)\r\n    }\r\n    traversal(func){\r\n      func(this)\r\n      this.children.forEach(child => child.traversal(func))\r\n    }\r\n    \r\n    \r\n}\r\n\r\n\r\nmodule.exports = {Node, TRS}","\r\n\r\nconst cube = {\r\n        name : '',\r\n        sTranslation : [0,0,0],\r\n        translation : [0,0,0],\r\n        rotation : [0,0,0],\r\n        scale : [1,1,1],\r\n        spriteName : 'BoxSprite',\r\n}\r\nmodule.exports = { cube}","\r\n\r\nconst {Node, TRS} =  require('../node')\r\nconst sprites = require('./sprites')\r\n\r\nconst m4 = require('../m4')\r\n\r\n\r\n\r\nclass RenderNode extends Node{\r\n    constructor(localMatrix, name, source,spriteName){\r\n        super(localMatrix, name, source)\r\n        \r\n        this.sprite = new sprites[spriteName]()\r\n        \r\n        this.objectsToDraw = []\r\n    }\r\n    updateObjectsToDraw(){\r\n        this.updatePartsList()\r\n        this.objectsToDraw = this.parts.filter(part => part.sprite)\r\n    }\r\n}\r\nconst makeRenderNode = (desc)=>{\r\n    const source = new TRS()\r\n   \r\n    source.translation = desc.sTranslation\r\n    \r\n    \r\n    \r\n    matrix = m4.xRotation( desc.rotation[0])\r\n    matrix = m4.yRotate(matrix,desc.rotation[1])\r\n    matrix = m4.zRotate(matrix,desc.rotation[2])\r\n    matrix = m4.translate(matrix, ...desc.translation)\r\n    matrix = m4.scale(matrix, ...desc.scale)\r\n    const node = new RenderNode(matrix,desc.name,source, desc.spriteName)\r\n    \r\n    if(desc.children){\r\n        desc.children.forEach(childDesc =>{\r\n            const child = makeRenderNode(childDesc)\r\n            child.setParent(node)\r\n        })\r\n    }\r\n    return node\r\n}\r\nmodule.exports = {RenderNode, makeRenderNode}\r\n","const {expandedTypedArray} = require( './programm.js')\r\n\r\n\r\n\r\nconst CUBE_FACE_INDICES = [\r\n    [3, 7, 5, 1], // right\r\n    [6, 2, 0, 4], // left\r\n    [6, 7, 3, 2], // ??\r\n    [0, 1, 5, 4], // ??\r\n    [7, 6, 4, 5], // front\r\n    [2, 3, 1, 0], // back\r\n  ];\r\n\r\n\r\nfunction createBoxGeometry(_a = 1, _b = 1, _c = 1){\r\n    const a = _a/2, b = _b/2, c = _c/2\r\n    const cornerVertices = [\r\n        [-a, -b, -c],\r\n        [+a, -b, -c],\r\n        [-a, +b, -c],\r\n        [+a, +b, -c],\r\n        [-a, -b, +c],\r\n        [+a, -b, +c],\r\n        [-a, +b, +c],\r\n        [+a, +b, +c],\r\n      ];\r\n  \r\n      const faceNormals = [\r\n        [+1, +0, +0],\r\n        [-1, +0, +0],\r\n        [+0, +1, +0],\r\n        [+0, -1, +0],\r\n        [+0, +0, +1],\r\n        [+0, +0, -1],\r\n      ];\r\n  \r\n      const uvCoords = [\r\n        [1, 0],\r\n        [0, 0],\r\n        [0, 1],\r\n        [1, 1],\r\n      ];\r\n      const numVertices = 6 * 4\r\n      const positions = expandedTypedArray(new Float32Array(numVertices * 3))\r\n      const normals   = expandedTypedArray(new Float32Array(numVertices * 3))\r\n      //const texCoords = webglUtils.createAugmentedTypedArray(2 , numVertices);\r\n      const indices   = expandedTypedArray(new Uint16Array(6 * 2 * 3))\r\n  \r\n      for (let f = 0; f < 6; ++f) {\r\n        const faceIndices = CUBE_FACE_INDICES[f];\r\n        for (let v = 0; v < 4; ++v) {\r\n          const position = cornerVertices[faceIndices[v]];\r\n          const normal = faceNormals[f];\r\n          positions.push(position)\r\n          normals.push(normal)\r\n          \r\n          \r\n  \r\n        }\r\n        \r\n        const offset = 4 * f;\r\n        indices.push(offset + 0, offset + 1, offset + 2);\r\n        indices.push(offset + 0, offset + 2, offset + 3);\r\n      }\r\n  \r\n      return {\r\n        position: positions,\r\n        normal: normals,\r\n        \r\n        indices: indices,\r\n      };\r\n}\r\n\r\n\r\n\r\n\r\n function createGeometry(arrays){\r\n  const v = arrays.v\r\n  const vt = arrays.vt\r\n  const vn = arrays.vn\r\n  const f = arrays.f\r\n  const numFaces = f.length\r\n  const facesSize = f[0].length\r\n  const numVertices = numFaces * facesSize\r\n  const positions = expandedTypedArray(new Float32Array(numVertices * 3))\r\n  const normals   = expandedTypedArray(new Float32Array(numVertices * 3))\r\n  const indices   = expandedTypedArray(new Uint16Array(numFaces * 2 * 3))\r\n  for (let i = 0; i < numFaces; ++i) {\r\n    const faceIndices = f[i];\r\n    for (let j = 0; j < facesSize; ++j) {\r\n      const position = v[faceIndices[j] - 1];\r\n      const normal = vn[i];\r\n    \r\n      positions.push(position)\r\n      //normals.push(normal)\r\n      \r\n      //texCoords.push(uv);\r\n\r\n    }\r\n    \r\n    const offset = 4 * i;\r\n    indices.push(offset + 0, offset + 1, offset + 2);\r\n    indices.push(offset + 0, offset + 2, offset + 3);\r\n  } \r\n  return {position : positions, normal : normals, indices}\r\n}\r\n\r\nconst linedBoxIndices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, //front\r\n  0, 5, 5, 4, 4, 1, 1, 0, //bottom\r\n  0, 4, 4, 7, 7, 3, 3, 0, //left\r\n  1, 2, 2, 6, 6, 5, 5, 1, //right\r\n  4, 5, 5, 6, 6, 7, 7, 4, // back\r\n  2, 7, 7, 3, 3, 6, 6, 2 // top \r\n])\r\nmodule.exports = {createBoxGeometry, createGeometry, linedBoxIndices}","\r\nfunction getGLTypeForTypedArray(gl, typedArray) {\r\n    if (typedArray instanceof Int8Array)    { return gl.BYTE; }            // eslint-disable-line\r\n    if (typedArray instanceof Uint8Array)   { return gl.UNSIGNED_BYTE; }   // eslint-disable-line\r\n    if (typedArray instanceof Int16Array)   { return gl.SHORT; }           // eslint-disable-line\r\n    if (typedArray instanceof Uint16Array)  { return gl.UNSIGNED_SHORT; }  // eslint-disable-line\r\n    if (typedArray instanceof Int32Array)   { return gl.INT; }             // eslint-disable-line\r\n    if (typedArray instanceof Uint32Array)  { return gl.UNSIGNED_INT; }    // eslint-disable-line\r\n    if (typedArray instanceof Float32Array) { return gl.FLOAT; }           // eslint-disable-line\r\n    return false\r\n  }\r\nfunction expandedTypedArray(array){\r\n   \r\n    let cursor = 0\r\n    array.push = function(){\r\n        for (let ii = 0; ii < arguments.length; ++ii) {\r\n          const value = arguments[ii];\r\n          \r\n          if (value instanceof Array || (value.buffer && value.buffer instanceof ArrayBuffer)) {\r\n            for (let jj = 0; jj < value.length; ++jj) {\r\n              array[cursor++] = value[jj];\r\n            }\r\n          } else {\r\n            array[cursor++] = value;\r\n          }\r\n        }\r\n        \r\n      }\r\n      \r\n      return array\r\n  }\r\n\r\nfunction createUniformSetters(gl, program){\r\n    let textureUnit = 0\r\n\r\n    function createUniformSetter(program, uniformInfo) {\r\n    \r\n        const location = gl.getUniformLocation(program, uniformInfo.name)\r\n        const type = uniformInfo.type\r\n        const isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === '[0]');\r\n        \r\n        if (type === gl.FLOAT && isArray) {\r\n        return function(v) {\r\n            gl.uniform1fv(location, v);\r\n        };\r\n        }\r\n        if (type === gl.FLOAT) {\r\n        return function(v) {\r\n            gl.uniform1f(location, v);\r\n        };\r\n        }\r\n        if (type === gl.FLOAT_VEC2) {\r\n        return function(v) {\r\n            gl.uniform2fv(location, v);\r\n        };\r\n        }\r\n        if (type === gl.FLOAT_VEC3) {\r\n        return function(v) {\r\n            gl.uniform3fv(location, v);\r\n        };\r\n        }\r\n        if (type === gl.FLOAT_VEC4) {\r\n        return function(v) {\r\n            gl.uniform4fv(location, v);\r\n        };\r\n        }\r\n        if (type === gl.INT && isArray) {\r\n        return function(v) {\r\n            gl.uniform1iv(location, v);\r\n        };\r\n        }\r\n        if (type === gl.INT) {\r\n        return function(v) {\r\n            gl.uniform1i(location, v);\r\n        };\r\n        }\r\n        if (type === gl.INT_VEC2) {\r\n        return function(v) {\r\n            gl.uniform2iv(location, v);\r\n        };\r\n        }\r\n        if (type === gl.INT_VEC3) {\r\n        return function(v) {\r\n            gl.uniform3iv(location, v);\r\n        };\r\n        }\r\n        if (type === gl.INT_VEC4) {\r\n        return function(v) {\r\n            gl.uniform4iv(location, v);\r\n        };\r\n        }\r\n        if (type === gl.BOOL) {\r\n        return function(v) {\r\n            gl.uniform1iv(location, v);\r\n        };\r\n        }\r\n        if (type === gl.BOOL_VEC2) {\r\n        return function(v) {\r\n            gl.uniform2iv(location, v);\r\n        };\r\n        }\r\n        if (type === gl.BOOL_VEC3) {\r\n        return function(v) {\r\n            gl.uniform3iv(location, v);\r\n        };\r\n        }\r\n        if (type === gl.BOOL_VEC4) {\r\n        return function(v) {\r\n            gl.uniform4iv(location, v);\r\n        };\r\n        }\r\n        if (type === gl.FLOAT_MAT2) {\r\n        return function(v) {\r\n            gl.uniformMatrix2fv(location, false, v);\r\n        };\r\n        }\r\n        if (type === gl.FLOAT_MAT3) {\r\n        return function(v) {\r\n            gl.uniformMatrix3fv(location, false, v);\r\n        };\r\n        }\r\n        if (type === gl.FLOAT_MAT4) {\r\n        return function(v) {\r\n            gl.uniformMatrix4fv(location, false, v);\r\n        };\r\n        }    \r\n    }\r\n    const uniformSetters = { };\r\n    const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\r\n    \r\n    for (let ii = 0; ii < numUniforms; ++ii) {\r\n      const uniformInfo = gl.getActiveUniform(program, ii);\r\n      if (!uniformInfo) {\r\n        break;\r\n      }\r\n      \r\n      let name = uniformInfo.name;\r\n      \r\n      if (name.substr(-3) === '[0]') {\r\n        name = name.substr(0, name.length - 3);\r\n      }\r\n      if(uniformInfo.size > 1){\r\n        for(let i = 0; i < uniformInfo.size; i++){\r\n          const obj = {size : uniformInfo.size, type : uniformInfo.type, name : name + `[${i}]`}\r\n          uniformSetters[name + `[${i}]`] = createUniformSetter(program, obj );\r\n        }\r\n      }\r\n      else{\r\n        const setter = createUniformSetter(program, uniformInfo);\r\n        uniformSetters[name] = setter;\r\n      }\r\n      \r\n    }\r\n    return uniformSetters\r\n}\r\nfunction createAttribSetters(gl, program){\r\n    const setters = {}\r\n    \r\n    const numAtrribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES)\r\n    for(let i = 0; i < numAtrribs; i++){\r\n      const attribInfo = gl.getActiveAttrib(program,i)\r\n      const location = gl.getAttribLocation(program,attribInfo.name)\r\n      setters[attribInfo.name] = function(bufferInfo){\r\n \r\n        const {numComponents, type, buffer} = bufferInfo\r\n        gl.enableVertexAttribArray(location)\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)\r\n        gl.vertexAttribPointer(location, numComponents, type, false, 0,0)\r\n      }\r\n    }\r\n    return setters\r\n  }\r\nfunction createBuffersInfo(gl,arrays){\r\n    const buffersInfo = {}\r\n    buffersInfo.attribs = {}\r\n    Object.keys(arrays).forEach(key =>{\r\n        if(key === 'indices') return \r\n        const buffer = gl.createBuffer()\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)\r\n        gl.bufferData(gl.ARRAY_BUFFER, arrays[key],gl.STATIC_DRAW)\r\n        buffersInfo.attribs['a_' + key] = {\r\n            buffer,\r\n            numComponents : 3,\r\n            type : getGLTypeForTypedArray(gl,arrays[key])\r\n        }\r\n     \r\n    })\r\n\r\n    if(arrays.indices){\r\n        const buffer = gl.createBuffer()\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer)\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices,gl.STATIC_DRAW)\r\n        buffersInfo.indices = buffer\r\n        buffersInfo.numElements = arrays.indices.length\r\n        return buffersInfo\r\n    }\r\n    buffersInfo.numElements = arrays.position.length / 3\r\n    return buffersInfo\r\n  }\r\n\r\n\r\n\r\n\r\n\r\nclass ProgrammInfo{\r\n    constructor(gl, vs, fs){\r\n        this.gl = gl\r\n        this.vertexShader = gl.createShader(gl.VERTEX_SHADER)\r\n        gl.shaderSource(this.vertexShader, vs)\r\n        gl.compileShader(this.vertexShader)\r\n        if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {\r\n            throw new Error(gl.getShaderInfoLog(this.vertexShader))\r\n        }\r\n\r\n        this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)\r\n        gl.shaderSource(this.fragmentShader, fs)\r\n        gl.compileShader(this.fragmentShader)\r\n        if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {\r\n            throw new Error(gl.getShaderInfoLog(this.fragmentShader))\r\n        }\r\n        \r\n\r\n        this.prg = gl.createProgram()\r\n        gl.attachShader(this.prg, this.vertexShader)\r\n        gl.attachShader(this.prg, this.fragmentShader)\r\n        gl.linkProgram(this.prg)\r\n        if (!gl.getProgramParameter(this.prg, gl.LINK_STATUS)) {\r\n            throw new Error(gl.getProgramInfoLog(this.prg))\r\n        }\r\n\r\n        \r\n        this.uniformSetters = createUniformSetters(gl, this.prg)\r\n        this.attributeSetters = createAttribSetters(gl, this.prg)\r\n        \r\n    }\r\n    setUniforms(uniforms){\r\n        \r\n        Object.keys(uniforms).forEach(name=>{\r\n            const setter = this.uniformSetters[name]\r\n            if(setter) setter(uniforms[name])\r\n        })\r\n    }\r\n    setAttributes(buffers){\r\n \r\n        Object.keys(buffers.attribs).forEach(key =>{\r\n            const setter = this.attributeSetters[key]\r\n            if(setter){\r\n              setter(buffers.attribs[key])\r\n            }\r\n        })\r\n        if(buffers.indices){\r\n            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, buffers.indices)\r\n        }\r\n    }\r\n}\r\n\r\nexport {\r\n    expandedTypedArray, ProgrammInfo, createBuffersInfo\r\n}","\r\nconst m4 = require('../m4')\r\nfunction resizeCanvasToDisplaySize(canvas, multiplier) {\r\n  multiplier = multiplier || 1;\r\n  const width  = canvas.clientWidth  * multiplier | 0;\r\n  const height = canvas.clientHeight * multiplier | 0;\r\n  if (canvas.width !== width ||  canvas.height !== height) {\r\n    canvas.width  = width;\r\n    canvas.height = height;\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n  \r\n \r\n    function degToRad(d) {\r\n        return d * Math.PI / 180;\r\n    }\r\n    var fieldOfViewRadians = degToRad(90);\r\n\r\nconst zNear = 0.01;\r\nconst zFar = 2000;\r\nvar aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\nconst projectionMatrix = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar)\r\n\r\nfunction drawScene(objectsToDraw,cameraMatrix, globalUniforms, type) {\r\n        \r\n        \r\n        \r\n        \r\n        var viewMatrix = m4.inverse(cameraMatrix)\r\n        var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix)\r\n\r\n        let lastUsedProgramInfo = null\r\n        let lastUsedBufferInfo = null\r\n        \r\n        for(let i = 0, n = objectsToDraw.length; i < n; ++i){\r\n          const object = objectsToDraw[i]\r\n          const sprite = object.sprite\r\n          if(lastUsedBufferInfo != sprite.buffersInfo){\r\n            lastUsedBufferInfo = sprite.buffersInfo\r\n          }\r\n          if(lastUsedProgramInfo != sprite.programmInfo){\r\n            lastUsedProgramInfo = sprite.programmInfo\r\n            gl.useProgram(lastUsedProgramInfo.prg)\r\n          }\r\n          \r\n   \r\n          sprite.uniforms.u_matrix = m4.multiply(viewProjectionMatrix, object.worldMatrix)\r\n          \r\n          sprite.uniforms.u_world =  object.worldMatrix\r\n          sprite.uniforms.u_worldInverseTranspose = m4.transpose(m4.inverse(object.worldMatrix))\r\n          lastUsedProgramInfo.setAttributes(lastUsedBufferInfo)\r\n          lastUsedProgramInfo.setUniforms( sprite.uniforms)\r\n          if(globalUniforms)lastUsedProgramInfo.setUniforms(globalUniforms)\r\n          gl.drawElements(gl.TRIANGLES, sprite.buffersInfo.numElements, gl.UNSIGNED_SHORT, 0) \r\n        } \r\n      }\r\n\r\nconst pointvs =\r\n      'uniform mat4 u_matrix;' +\r\n      \r\n      'void main(void) {' +\r\n         'gl_Position = u_matrix * vec4(0.0,0.0,0.0,1.0);' +\r\n         'gl_PointSize = 1.0;'+\r\n      '}';\r\nconst defaultFs =\r\n      'precision mediump float;' +\r\n      'uniform vec4 u_color;' +\r\n      'void main(void) {' +\r\n         ' gl_FragColor = u_color;' +\r\n      '}';\r\n      \r\n      const {createBuffersInfo,ProgrammInfo} = require('./programm')\r\n      \r\nconst pointGeometry = {position : new Float32Array(0.0,0.0,0.0)}\r\nconst pointBuffersInfo = createBuffersInfo(gl,pointGeometry)\r\nconst pointProgrammInfo = new ProgrammInfo(gl, pointvs, defaultFs)\r\n\r\n\r\n\r\n\r\nconst planePoints = {position : new Float32Array([\r\n  -100.0,  0.0, -100.0,\r\n  -100.0,  0.0,  100.0,\r\n   100.0,  0.0,  100.0,\r\n   100.0,  0.0, -100.0]),\r\n  indices : new Uint16Array([0,  1,  2,      0,  2,  3])}\r\nconst planeVs = \r\n  'uniform mat4 u_matrix;' +\r\n  'attribute vec4 a_position;'+      \r\n  'void main(void) {' +\r\n    'gl_Position = u_matrix * a_position;' +\r\n    'gl_PointSize = 10.0;'+\r\n  '}';\r\n\r\nconst planeProgrammInfo = new ProgrammInfo(gl, planeVs, defaultFs)\r\nconst planeBuffersInfo = createBuffersInfo(gl, planePoints)\r\n\r\nfunction simpleDraw(programInfo, buffersInfo, type, numElements, list, u_color, cameraMatrix){\r\n  \r\n  \r\n      \r\n      gl.useProgram(programInfo.prg)\r\n      programInfo.setAttributes(buffersInfo)\r\n      let viewProjectionMatrix\r\n      if(cameraMatrix)viewProjectionMatrix = m4.multiply(projectionMatrix, m4.inverse(cameraMatrix))\r\n      else viewProjectionMatrix = m4.identity()\r\n      list.forEach(element =>{\r\n        const mat = element\r\n        const u_matrix = m4.multiply(viewProjectionMatrix,mat)\r\n        programInfo.setUniforms({u_matrix, u_color : u_color})\r\n        \r\n        gl.drawElements(type, numElements || buffersInfo.numElements, gl.UNSIGNED_SHORT, 0) \r\n    })\r\n  }\r\n\r\n\r\n\r\nconst lineIndices = new Uint16Array([0,1])\r\nconst lineVs = \r\n  'uniform mat4 u_matrix;' +\r\n  'attribute vec4 a_position;'+      \r\n  'void main(void) {' +\r\n    'gl_Position = u_matrix * a_position;' +\r\n    \r\n  '}';\r\n\r\nconst lineProgramInfo = new ProgrammInfo(gl, lineVs,defaultFs)\r\n\r\n\r\nconst drawPoints = simpleDraw.bind(null, pointProgrammInfo, pointBuffersInfo, gl.POINT,3 )\r\nconst drawPlanes = simpleDraw.bind(null,planeProgrammInfo, planeBuffersInfo, gl.TRIANGLES, 6)\r\nconst drawLines = function(lines, color, cameraMatrix){\r\n    lines.forEach(line =>{\r\n      const lineGeometry =  {position : new Float32Array([...line[0], ...line[1]]),\r\n                            }\r\n      \r\n      const lineBuffersInfo = createBuffersInfo(gl,lineGeometry)\r\n      \r\n      simpleDraw(lineProgramInfo, lineBuffersInfo, gl.LINES,2, [m4.identity()], color, cameraMatrix)\r\n    })\r\n}\r\n\r\n\r\nmodule.exports = {drawScene, drawPoints, drawPlanes, drawLines, resizeCanvasToDisplaySize}\r\n\r\n","\r\nconst {createBoxGeometry, linedBoxIndices} = require('./primitives')\r\nconst {createBuffersInfo,ProgrammInfo} = require('./programm')\r\nconst m4 = require('../m4')\r\nconst geometry = createBoxGeometry()\r\n//geometry.indices = linedBoxIndices\r\nconst buffersInfo = createBuffersInfo(gl,geometry)\r\nconst vs = document.getElementById('vertex-shader-3d').text\r\nconst fs = document.getElementById('fragment-shader-3d').text\r\nconst programmInfo = new ProgrammInfo(gl, vs, fs)\r\nfunction Box(size,color = [0.5,0.5,0.5,1]){\r\n    return {\r\n        buffersInfo,\r\n        programmInfo,\r\n        sizeMatrix : m4.scaling( ...size),\r\n        uniforms : {\r\n            u_color : color,\r\n            u_matrix : null,\r\n            u_world : null\r\n        }\r\n    }\r\n}\r\nclass BoxSprite{\r\n    constructor(color = [0.5,0.5,0.5,1]){\r\n        this.buffersInfo = buffersInfo\r\n        this.programmInfo = programmInfo\r\n        this.uniforms = {\r\n            u_color : color,\r\n            u_matrix : null,\r\n            u_world : null,\r\n        }\r\n        }\r\n}\r\nconst planeVs = \r\n  'uniform mat4 u_matrix;' +\r\n  'attribute vec4 a_position;'+      \r\n  'void main(void) {' +\r\n    'gl_Position = u_matrix * a_position;' +\r\n    'gl_PointSize = 10.0;'+\r\n  '}';\r\n  const lineVs = \r\n  'uniform mat4 u_matrix;' +\r\n  'attribute vec4 a_position;'+      \r\n  'void main(void) {' +\r\n    'gl_Position = u_matrix * a_position;' +\r\n    \r\n  '}';\r\n  const pointVs =\r\n  'uniform mat4 u_matrix;' +\r\n  \r\n  'void main(void) {' +\r\n     'gl_Position = u_matrix * vec4(0.0,0.0,0.0,1.0);' +\r\n     'gl_PointSize = 10.0;'+\r\n  '}';\r\nconst defaultFs =\r\n  'precision mediump float;' +\r\n  'uniform vec4 u_color;' +\r\n  'void main(void) {' +\r\n     ' gl_FragColor = u_color;' +\r\n  '}';\r\nconst pointProgrammInfo = new ProgrammInfo(gl, pointVs, defaultFs)\r\nclass PointsSprite {\r\n    constructor(points,color){\r\n        this.programmInfo = pointProgrammInfo\r\n        this.uniforms = {\r\n            u_color : color,\r\n            u_matrix : null,\r\n            u_world : null\r\n        }\r\n        this.buffersInfo = createBuffersInfo({position : new Float32Array(points)})\r\n        this.type = gl.POINT\r\n    }\r\n}\r\nconst linesProgramInfo = new ProgrammInfo(gl, lineVs, defaultFs)\r\n\r\nclass LineSprite {\r\n    constructor(points,color){\r\n        this.programmInfo = linesProgramInfo\r\n        this.uniforms = {\r\n            u_color : color,\r\n            u_matrix : null,\r\n            u_world : null\r\n        }\r\n        \r\n        let indices = []\r\n        for(let i = 0, n = points.length/3; i < n; i++){\r\n            indices.push(i,i+1)\r\n        }\r\n        indices[indices.length - 1] = 0\r\n        indices = new Uint16Array(indices)\r\n        \r\n        this.buffersInfo = createBuffersInfo(gl,{position : new Float32Array(points), indices})\r\n        this.type = gl.LINES\r\n    }\r\n}\r\nmodule.exports = { LineSprite, PointsSprite, BoxSprite}","\r\n\r\nconst {Vector} = require('./vectors')\r\nconst {EventEmitter} = require('./eventEmitter')\r\nconst m4 = require('../m4')\r\nconst m3 = require('../m3')\r\nconst xAxis = new Vector(1,0,0)\r\nconst yAxis = new Vector(0,1,0)\r\nconst zAxis = new Vector(0,0,1)\r\nconst xAxisNegative = xAxis.multiply(-1)\r\nconst yAxisNegative = yAxis.multiply(-1)\r\nconst zAxisNegative = zAxis.multiply(-1)\r\nconst dirs = [xAxis,yAxis,zAxis,xAxisNegative,yAxisNegative, zAxisNegative]\r\n\r\nclass Box extends EventEmitter{\r\n    constructor(a = 1,b = 1,c = 1){\r\n        super()\r\n        this.min = new Vector(-a/2,-b/2,-c/2)\r\n        this.max = new Vector(a/2,b/2,c/2)\r\n        this.Rmatrix = m3.identity()\r\n        this.RmatrixInverse = m3.identity()\r\n        this.RS = m3.identity()\r\n        this.pos = new Vector(0,0,0)\r\n    }\r\n    getAABB(){\r\n        const maxX = this.support(xAxis).x\r\n        const maxY = this.support(yAxis).y\r\n        const maxZ = this.support(zAxis).z\r\n\r\n        const minX = this.support(xAxisNegative).x\r\n        const minY = this.support(yAxisNegative).y\r\n        const minZ = this.support(zAxisNegative).z\r\n        return [new Vector(minX, minY, minZ), new Vector(maxX, maxY, maxZ)]\r\n    }\r\n    translate(tx,ty,tz){\r\n        this.pos.x += tx\r\n        this.pos.y += ty\r\n        this.pos.z += tz\r\n    }\r\n    rotate(ax,ay,az){\r\n        this.Rmatrix = m3.xRotate(this.Rmatrix, ax)\r\n        this.Rmatrix = m3.yRotate(this.Rmatrix, ay)\r\n        this.Rmatrix = m3.zRotate(this.Rmatrix, az)\r\n\r\n        this.RmatrixInverse = m3.transpose(this.Rmatrix)\r\n    }\r\n    setRmatrix(matrix){\r\n        this.Rmatrix = matrix\r\n        this.RmatrixInverse = m3.transpose(matrix)\r\n    }\r\n    support(dir){\r\n        const _dir = m3.transformPoint(this.RmatrixInverse, dir.toArray())\r\n        \r\n        const res = new Vector(0,0,0)\r\n        \r\n        res[0]= _dir[0] > 0 ? this.max.x : this.min.x\r\n        res[1] = _dir[1] > 0 ? this.max.y : this.min.y\r\n        res[2] = _dir[2] > 0 ? this.max.z : this.min.z\r\n        \r\n        const sup = new Vector(...m4.transformPoint(this.getM4(), res))\r\n        this.emit('sup', sup,dir)\r\n        return sup\r\n  \r\n    }\r\n    getInverseInertiaTensor(mass){\r\n        const i1 = mass/12 * (this.max.y * this.max.y + this.max.z * this.max.z)\r\n        const i2 = mass / 12 *(this.max.x * this.max.x + this.max.z * this.max.z)\r\n        const i3 = mass / 12 *(this.max.x * this.max.x + this.max.y * this.max.y)\r\n        \r\n        const m = new Float32Array([1/i1, 0, 0, 0, 1/i2, 0, 0, 0, 1/i3])\r\n        \r\n        return m3.multiply(this.Rmatrix,(m3.multiply(this.RmatrixInverse,m)))\r\n\r\n    }\r\n    getM4(){\r\n        const m = m4.m3Tom4(this.Rmatrix)\r\n        m[12] = this.pos.x\r\n        m[13] = this.pos.y\r\n        m[14] = this.pos.z\r\n        m[15] = 1\r\n        return m\r\n    }\r\n    test(){\r\n        return dirs.map(d =>this.support(d).toArray())\r\n    }\r\n}\r\n\r\n \r\nmodule.exports = { Box}","const {Vector, cross, dot,normalize} = require('./vectors')\r\nconst m3 = require('../m3')\r\nconst tol = 0.005\r\nconst tol2 = 0.002\r\nconst numIterations = 7\r\nfunction getCollisionResolution(manifold, deltaTime){\r\n    const body1 = manifold.body1\r\n    const body2 = manifold.body2\r\n    \r\n    for(let j = 0; j <  numIterations; j++){\r\n        for(let i = 0, n = manifold.contacts.length; i< n; i++){\r\n            let vel1 = body1.velocity\r\n            let vel2 = body2.velocity\r\n            let omega1 = body1.angularV\r\n            let omega2 = body2.angularV\r\n            const contact = manifold.contacts[i]\r\n            const I1 = body1.getInverseInertiaTensor()\r\n            const I2 = body2.getInverseInertiaTensor()\r\n            const M1 = body1.inverseMass\r\n            const M2 = body2.inverseMass\r\n            const normal = normalize(contact.n)\r\n            let J1 = normal.multiply(-1)\r\n            let J2 = cross(normal, contact.ra)\r\n            let J3 = normal\r\n            let J4 = cross(contact.rb, normal)\r\n            \r\n            \r\n        \r\n        \r\n            const penDepth = contact.n.norm()\r\n            const Vc = dot(vel2.add(cross(omega2, contact.rb)).substract(vel1).substract(cross(omega1, contact.ra)),normal)\r\n            const restitution =  Math.max(Vc - tol2, 0) * 0.1\r\n    \r\n            let b = Math.max(0,penDepth-tol)/deltaTime *0.1 + restitution\r\n            \r\n            const k1 = dot(J1, vel1) + dot(J2, omega1) + dot(J3, vel2) + dot(J4, omega2) - b\r\n        \r\n            const Ma = [M1, 0, 0,\r\n                        0, M1, 0,\r\n                        0, 0, M1 ]\r\n            const Mb = [M2, 0, 0,\r\n                        0, M2, 0,\r\n                        0, 0, M2]\r\n            const JMa = m3.dot(m3.transformPoint(Ma, J1.toArray()),J1.toArray())\r\n            const JIa = m3.dot(m3.transformPoint(I1, J2.toArray()), J2.toArray())\r\n            const JMb = m3.dot(m3.transformPoint(Mb, J3.toArray()), J3.toArray())\r\n            const JIb = m3.dot(m3.transformPoint(I2, J4.toArray()), J4.toArray())\r\n            const k2 = (JMa + JMb + JIa + JIb)\r\n            \r\n            \r\n            let lambda = -k1/k2\r\n            let oldAcc = contact.accI\r\n            contact.accI += lambda\r\n            if(contact.accI < 0) contact.accI = 0\r\n            lambda = contact.accI - oldAcc\r\n            \r\n            \r\n            vel1 = J1.multiply(lambda * M1)\r\n            body1.addVelocity(vel1)\r\n            omega1 = (new Vector(...m3.transformPoint(I1,J2.toArray()))).multiply(lambda)\r\n            body1.addAngularV(omega1)\r\n            vel2 = J3.multiply(lambda * M2)\r\n            body2.addVelocity(vel2)\r\n            omega2 = (new Vector(...m3.transformPoint(I2, J4.toArray()))).multiply(lambda)\r\n            body2.addAngularV(omega2)\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n}\r\nconst warmStart = (manifold, deltaTime) =>{\r\n    const body1 = manifold.body1\r\n    const body2 = manifold.body2\r\n    \r\n    for(let i = 0, n = manifold.contacts.length; i< n; i++){\r\n        let vel1 = body1.velocity\r\n        let vel2 = body2.velocity\r\n        let omega1 = body1.angularV\r\n        let omega2 = body2.angularV\r\n        const contact = manifold.contacts[i]\r\n        const I1 = body1.getInverseInertiaTensor()\r\n        const I2 = body2.getInverseInertiaTensor()\r\n        const M1 = body1.inverseMass\r\n        const M2 = body2.inverseMass\r\n        const normal = normalize(contact.n)\r\n        let J1 = normal.multiply(-1)\r\n        let J2 = cross(normal, contact.ra)\r\n        let J3 = normal\r\n        let J4 = cross(contact.rb, normal)\r\n\r\n\r\n        const lambda = manifold.contacts[i].accI * deltaTime\r\n        vel1 = J1.multiply(lambda * M1)\r\n        body1.addVelocity(vel1)\r\n        \r\n        omega1 = (new Vector(...m3.transformPoint(I1,J2.toArray()))).multiply(lambda)\r\n        body1.addAngularV(omega1)\r\n        vel2 = J3.multiply(lambda * M2)\r\n        body2.addVelocity(vel2)\r\n        omega2 = (new Vector(...m3.transformPoint(I2, J4.toArray()))).multiply(lambda)\r\n        body2.addAngularV(omega2)\r\n    }\r\n    \r\n}\r\nmodule.exports = {getCollisionResolution, warmStart}","class EventEmitter{\r\n    constructor(){\r\n        this.events = {}\r\n    }\r\n    on(eventName, fn){\r\n        if(!this.events[eventName]){\r\n            this.events[eventName] = []\r\n        }\r\n        this.events[eventName].push(fn)\r\n        return () =>{\r\n            this.events[eventName] = this.events[eventName].filter(eventFn => fn !== eventFn)\r\n        }\r\n    }\r\n    emit(eventName, data){\r\n        if(this.events[eventName]){\r\n            this.events[eventName].forEach(fn => {\r\n                fn.call(null,data)\r\n               \r\n            })\r\n\r\n        }\r\n    }\r\n}\r\nmodule.exports = {EventEmitter}","\r\nconst {Vector, dot, cross, normalize} =  require('./vectors')\r\n\r\n\r\nconst GJK_MAX_ITERATIONS_NUM = 64\r\n\r\n\r\nconst update_simplex3 = () =>{\r\n        \r\n    const n = cross(b.substract(a),c.substract(a))\r\n    const AO = a.multiply(-1)\r\n    \r\n    simp_dim = 2\r\n    if(dot(cross(b.substract(a), n), AO) > 0){\r\n        c = a\r\n        search_dir = cross(cross(b.substract(a), AO),b.substract(a))\r\n        return\r\n    }\r\n    if(dot(cross(n, c.substract(a)),AO) > 0){ \r\n        b = a\r\n        search_dir = cross(cross(c.substract(a), AO),c.substract(a))\r\n        return\r\n    }\r\n    simp_dim = 3\r\n    if(dot(n, AO) > 0){\r\n        d = c\r\n        c = b\r\n        b = a\r\n        search_dir = n\r\n        return\r\n    }\r\n    d = b\r\n    b = a\r\n    search_dir = n.multiply(-1)\r\n    return\r\n}\r\nconst update_simplex4 = () =>{\r\n        \r\n    const ABC = cross(b.substract(a),(c.substract(a)))\r\n    const ACD = cross(c.substract(a),(d.substract(a)))\r\n    const ADB = cross(d.substract(a),(b.substract(a)))\r\n    const AO = a.multiply(-1)\r\n    simp_dim = 3\r\n\r\n    if(dot(ABC,AO) > 0){\r\n        d = c\r\n        c = b\r\n        b = a\r\n        search_dir = ABC\r\n        return false\r\n    }\r\n\r\n    if(dot(ACD,AO) > 0){\r\n        b = a\r\n        search_dir = ACD\r\n        return false\r\n    }\r\n\r\n    if(dot(ADB,(AO)) > 0){\r\n        c = d\r\n        d = b\r\n        b = a\r\n        search_dir = ADB\r\n        return false\r\n    }\r\n    return true\r\n}\r\nfunction gjk(body1,body2){\r\n    const coll1 = body1.collider\r\n    const coll2 = body2.collider\r\n    this.a, this.b, this.c, this.d, this.search_dir = new Vector(0,0,0), this.simp_dim = 2\r\n    this.originsMap = new Map()\r\n    \r\n\r\n    \r\n    \r\n    let mtv = new Vector(0,0,0)\r\n   \r\n    search_dir = coll1.pos.substract(coll2.pos)\r\n    const c_origin1 = coll1.support(search_dir.multiply(-1))\r\n    const c_origin2 = coll2.support(search_dir)\r\n    c = c_origin2.substract(c_origin1)\r\n    c.oa = c_origin1\r\n    c.ob = c_origin2\r\n    this.originsMap.set(c,[c_origin1, c_origin2])\r\n    \r\n    search_dir = c.multiply(-1)\r\n    \r\n    const b_origin1 = coll1.support(search_dir.multiply(-1))\r\n    const b_origin2 = coll2.support(search_dir)\r\n    b = b_origin2.substract(b_origin1)\r\n    b.oa = b_origin1\r\n    b.ob = b_origin2\r\n    this.originsMap.set(b, [b_origin1, b_origin2])\r\n    \r\n    if(dot(b,search_dir) < 0){\r\n        \r\n        return false\r\n    }\r\n    \r\n    search_dir = cross(cross(c.substract(b),b.multiply(-1)),c.substract(b))\r\n    \r\n    if(search_dir.isNull()){\r\n        \r\n        search_dir = cross(c.substract(b),(new Vector(1,0,0)))\r\n        \r\n        if(search_dir.isNull()){\r\n            \r\n            search_dir = cross(c.substract(b),(new Vector(0,0,-1)))\r\n            \r\n        }\r\n    }\r\n    \r\n    simp_dim = 2\r\n    for(let i = 0; i < GJK_MAX_ITERATIONS_NUM; ++i){\r\n        \r\n        const a_origin1 = coll1.support(search_dir.multiply(-1))\r\n        const a_origin2 = coll2.support(search_dir)\r\n        a = a_origin2.substract(a_origin1)\r\n        a.oa = a_origin1\r\n        a.ob = a_origin2\r\n        this.originsMap.set(a, [a_origin1, a_origin2])\r\n        if(dot(a,search_dir) < 0 ) return false\r\n        \r\n        simp_dim ++\r\n        if(simp_dim === 3){\r\n            update_simplex3()\r\n        }\r\n        else if(update_simplex4()){\r\n            \r\n            return EPA(a,b,c,d,body1,body2)\r\n\r\n        }\r\n    }\r\n}\r\n\r\nconst baricentric = (face, point) =>{\r\n    let a11 = face[0].x\r\n    let a12 = face[1].x\r\n    let a13 = face[2].x\r\n    let b1 = point.x\r\n    let a21 = face[0].y\r\n    let a22 = face[1].y\r\n    let a23 = face[2].y\r\n    let b2 = point.y\r\n    let a31 = face[0].z\r\n    let a32 = face[1].z\r\n    let a33 = face[2].z\r\n    let b3 = point.z\r\n\r\n    const d = a11 * a22 * a33 \r\n    + a21 * a32 * a13\r\n    + a12 * a23 * a31\r\n    - a13 * a22 * a31\r\n    - a21 * a12 * a33\r\n    - a32 * a23 * a11\r\n\r\n    const d1 = b1 * a22 * a33 +\r\n    b2 * a32 * a13\r\n    + a12 * a23 * b3\r\n    - a13 * a22 * b3\r\n    - b2 * a12 * a33\r\n    - a32 * a23 * b1\r\n\r\n    const d2 = a11 * b2 * a33\r\n    + a21 * b3 * a13\r\n    + b1 * a23 * a31\r\n    - a13 * b2 * a31\r\n    - a11 * b3 * a23\r\n    - a21 * b1 * a33\r\n\r\n    const d3 = a11 * a22 * b3\r\n    + a21 * a32 * b1\r\n    + a12 * b2 * a31\r\n    - b1 * a22 * a31\r\n    - a21 * a12 * b3\r\n    - b2 * a32 * a11\r\n\r\n   return [d1/d , d2/d, d3/d ]\r\n}\r\nconst originToFaceProj = ( face) =>{\r\n        \r\n        \r\n        \r\n       \r\n\r\n    const normal = face[3]\r\n    const point = face[0]\r\n    const c = -normal.x * point.x - normal.y * point.y - normal.z * point.z\r\n\r\n    const t = - c / (normal.x * normal.x + normal.y * normal.y + normal.z * normal.z)\r\n\r\n\r\n\r\n\r\n    return new Vector(t * normal.x, t * normal.y, t * normal.z)\r\n}\r\n\r\nconst formContact = ()=>{\r\n    \r\n}\r\n\r\nconst TOLERANCE = 0.001\r\nconst MAX_NUM_FACES = 64\r\nconst MAX_NUM_LOOSE_EDGES = 32\r\nconst EPA_MAX_NUM_ITER = 64\r\nconst EPA = (a, b, c, d, body1, body2) =>{\r\n    const coll1 = body1.collider\r\n    const coll2 = body2.collider\r\n    const faces = []\r\n    for(let i = 0; i< 4; i++){\r\n        faces[i] = []\r\n    }\r\n\r\n    faces[0][0] = a\r\n    faces[0][1] = b\r\n    faces[0][2] = c\r\n    faces[0][3] = normalize(cross(b.substract(a),c.substract(a)))\r\n    faces[1][0] = a\r\n    faces[1][1] = c\r\n    faces[1][2] = d\r\n    faces[1][3] = normalize(cross(c.substract(a),d.substract(a)))\r\n    faces[2][0] = a\r\n    faces[2][1] = d\r\n    faces[2][2] = b\r\n    faces[2][3] = normalize(cross(d.substract(a),b.substract(a)))\r\n    faces[3][0] = b\r\n    faces[3][1] = d\r\n    faces[3][2] = c\r\n    faces[3][3] = normalize(cross(d.substract(b),c.substract(b)))\r\n    \r\n    let num_faces = 4\r\n    let closest_face = null\r\n    let search_dir\r\n   \r\n\r\n    let p\r\n    for(let iteration = 0; iteration < EPA_MAX_NUM_ITER; ++iteration){\r\n        let min_dist = dot(faces[0][0], faces[0][3])\r\n        \r\n       closest_face = 0\r\n        for(let i = 0; i < num_faces; ++i){\r\n            let dist = dot(faces[i][0],faces[i][3])\r\n            if(dist < min_dist){\r\n                min_dist = dist\r\n                closest_face = i\r\n            }\r\n        }\r\n        search_dir = faces[closest_face][3]\r\n        p = coll2.support(search_dir).substract(coll1.support(search_dir.multiply(-1)))\r\n        const p_origin1 = coll1.support(search_dir.multiply(-1))\r\n        const p_origin2 = coll2.support(search_dir)\r\n        p.oa = p_origin1\r\n        p.ob = p_origin2\r\n        originsMap.set(p, [ p_origin1, p_origin2])\r\n        if(dot(p,search_dir) - min_dist < 0.00001){\r\n            const face = faces[closest_face]\r\n\r\n            const point = originToFaceProj(face)\r\n            \r\n            \r\n            const [Aa, Ba] = originsMap.get(face[0])\r\n            //const Aa = face[0].oa\r\n            //const Ba = face[0].ob\r\n            const [Ab, Bb] = originsMap.get(face[1])\r\n            //const Ab = face[1].oa\r\n            //const Bb = face[1].ob\r\n            const [Ac, Bc] = originsMap.get(face[2])\r\n            //const Ac = face[2].oa\r\n            //const Bc = face[2].ob\r\n           \r\n            const result = baricentric(face,point)\r\n            \r\n            \r\n            let PA = Aa.multiply(result[0]).add(Ab.multiply(result[1])).add(Ac.multiply(result[2]))\r\n            let PB = Ba.multiply(result[0]).add(Bb.multiply(result[1])).add(Bc.multiply(result[2]))\r\n            \r\n            //const ra = PA.substract(coll1.pos)\r\n    \r\n            const rb = PB.substract(coll2.pos)\r\n            const ra = PA.substract(coll1.pos)\r\n            const n = face[3].multiply(-dot(p,search_dir))\r\n            if(n.isNull()) return false\r\n            return {PA, PB, n, ra, rb, accI : 0}\r\n        }\r\n\r\n        const loose_edges = []\r\n        let num_loose_edges = 0\r\n        for(let i = 0; i < num_faces;++i){\r\n           \r\n            if(dot(faces[i][3],p.substract(faces[i][0])) > 0){\r\n                \r\n                for(let j = 0; j < 3; j++){\r\n                    let current_edge = [faces[i][j], faces[i][(j + 1) % 3]]\r\n                    let found_edge = false\r\n                    for(let k = 0; k < num_loose_edges; k++){\r\n                        if(loose_edges[k][1] === current_edge[0] && loose_edges[k][0] === current_edge[1]){\r\n                            \r\n                            loose_edges[k][0] = loose_edges[num_loose_edges - 1][0]\r\n                            loose_edges[k][1] = loose_edges[num_loose_edges-1][1]\r\n                            num_loose_edges --\r\n                            found_edge = true\r\n                            k = num_loose_edges\r\n                        }\r\n                    }\r\n                    if(!found_edge){\r\n                        if(num_loose_edges >= MAX_NUM_LOOSE_EDGES) break;\r\n                       \r\n                        loose_edges[num_loose_edges] = []\r\n                        loose_edges[num_loose_edges][0] = current_edge[0]\r\n                        loose_edges[num_loose_edges][1] = current_edge[1]\r\n                        num_loose_edges++\r\n                    }\r\n                }\r\n                faces[i][0] = faces[num_faces - 1][0]\r\n                faces[i][1] = faces[num_faces - 1][1]\r\n                faces[i][2] = faces[num_faces - 1][2]\r\n                faces[i][3] = faces[num_faces - 1][3]\r\n                num_faces--\r\n                i--\r\n            }\r\n        }\r\n        for(let i = 0; i < num_loose_edges; i++){\r\n            if(num_faces >= MAX_NUM_FACES) break;\r\n            faces[num_faces]=[]\r\n            faces[num_faces][0] = loose_edges[i][0]\r\n            faces[num_faces][1] = loose_edges[i][1]\r\n            faces[num_faces][2] = p\r\n            \r\n            faces[num_faces][3] = normalize( cross( loose_edges[i][0].substract(loose_edges[i][1]), loose_edges[i][0].substract(p)))\r\n            if(dot(faces[num_faces][0], faces[num_faces][3]) + 0.01 < 0){\r\n                temp = faces[num_faces][0]\r\n                faces[num_faces][0] = faces[num_faces][1]\r\n                faces[num_faces][1] = temp\r\n                faces[num_faces][3] = faces[num_faces][3].multiply(-1)\r\n                \r\n            }\r\n            num_faces++\r\n        }\r\n        \r\n    }\r\n\r\n    const face = faces[closest_face]\r\n\r\n            const point = originToFaceProj(face)\r\n            \r\n            \r\n            const [Aa, Ba] = originsMap.get(face[0])\r\n            //const Aa = face[0].oa\r\n            //const Ba = face[0].ob\r\n            const [Ab, Bb] = originsMap.get(face[1])\r\n            //const Ab = face[1].oa\r\n            //const Bb = face[1].ob\r\n            const [Ac, Bc] = originsMap.get(face[2])\r\n            //const Ac = face[2].oa\r\n            //const Bc = face[2].ob\r\n           \r\n            const result = baricentric(face,point)\r\n            \r\n            \r\n            let PA = Aa.multiply(result[0]).add(Ab.multiply(result[1])).add(Ac.multiply(result[2]))\r\n            let PB = Ba.multiply(result[0]).add(Bb.multiply(result[1])).add(Bc.multiply(result[2]))\r\n            \r\n            //const ra = PA.substract(coll1.pos)\r\n            console.log(face)\r\n            const rb = PB.substract(coll2.pos)\r\n            const ra = PA.substract(coll1.pos)\r\n            const n = face[3].multiply(-dot(p,search_dir))\r\n            \r\n            return false\r\n\r\n}\r\nmodule.exports = {gjk}","\r\nconst {EventEmitter}  = require('./eventEmitter')\r\nconst {Vector} = require('./vectors')\r\nconst prec = 0.01\r\nclass Physics extends EventEmitter{\r\n    constructor(collider){\r\n        super()\r\n        this.static = false\r\n        this.collider = collider\r\n        this.mass = 1\r\n        this.inverseMass = 1/this.mass\r\n        this.velocity = new Vector(0, 0, 0)\r\n        this.acceleration = new Vector(0,0,0)\r\n        this.angularV = new Vector(0, 0, 0)\r\n        this.id = 1\r\n        this.acceleration = new Vector(0,0,0)\r\n        this.BVlink\r\n    }\r\n    update(dt){\r\n        let deltaSpeed = this.acceleration.multiply(dt)\r\n        this.velocity = this.velocity.add( deltaSpeed)\r\n        \r\n        const translation = this.velocity.multiply(dt)\r\n        this.translate(translation.x, translation.y, translation.z)\r\n        const deltaRotation = this.angularV.multiply(dt)\r\n        this.rotate(deltaRotation.x, deltaRotation.y, deltaRotation.z)\r\n        \r\n        this.emit('update')\r\n        return this\r\n    }\r\n    getInverseInertiaTensor(){\r\n        return this.collider.getInverseInertiaTensor(this.mass)\r\n    }\r\n    setMass(mass){\r\n        this.mass = mass\r\n        this.inverseMass = 1 / this.mass\r\n        \r\n    }\r\n    translate(tx,ty,tz){\r\n        \r\n        this.collider.translate(tx,ty,tz)\r\n\r\n        this.emit('translation')\r\n        return this\r\n    }\r\n    rotate(ax,ay,az){\r\n        \r\n        this.collider.rotate(ax,ay,az)\r\n\r\n        this.emit('rotation')\r\n        return this\r\n        \r\n    }\r\n    \r\n    addVelocity(v){\r\n        if(this.static)return\r\n        this.velocity = this.velocity.add(v)\r\n    }\r\n    addAngularV(v){\r\n        if(this.static)return\r\n        this.angularV = this.angularV.add(v)\r\n    }\r\n    addAcceleration(v){\r\n        this.acceleration = this.acceleration.add(v)\r\n    }\r\n    getExpandedAABB(){\r\n        const aabb = this.collider.getAABB()\r\n        const velocity = this.velocity\r\n        aabb[0].x -= prec\r\n        aabb[1].x += prec\r\n        aabb[0].y -= prec\r\n        aabb[0].z -= prec\r\n        aabb[1].y += prec\r\n        aabb[1].z += prec\r\n        if(velocity.x > 10) aabb[1].x += velocity.x\r\n        if(velocity.y > 10) aabb[1].y += velocity.y\r\n        if(velocity.z > 10) aabb[1].z += velocity.z\r\n        if(velocity.x < -10) aabb[0].x -= velocity.x\r\n        if(velocity.y < -10) aabb[0].y -= velocity.y\r\n        if(velocity.z < -10) aabb[0].z -= velocity.z\r\n        return aabb\r\n    }\r\n    getAABB(){\r\n        return this.collider.getAABB()\r\n    }\r\n    \r\n}\r\n\r\n\r\nmodule.exports = {Physics}","\r\nconst {Tree} = require('./tree')\r\n\r\nconst {getCollisionResolution, warmStart} = require('./constraints')\r\nconst {gjk} = require('./gjk')\r\nconst { distanceFromLine, findLargestFace} = require('./vectors')\r\n\r\nconst prec = 0.01\r\nconst pairHash = (x,y) => x === Math.max(x, y) ? x * x + x + y : y * y + x\r\n\r\n\r\n\r\n\r\n\r\nclass Simulation {\r\n    constructor(){\r\n        this.objects = []\r\n        this.bvh = new Tree()\r\n        this.collisions = []\r\n        this.collisionManifolds = new Map()\r\n        this.lastId = 0\r\n    }\r\n    addObject(object){   \r\n            \r\n            const aabb = object.getExpandedAABB()\r\n           \r\n            \r\n            const leaf = this.bvh.insertLeaf(aabb,object)\r\n            object.BVlink = leaf\r\n            object.id = this.lastId\r\n            this.lastId++\r\n            object.on('translation',()=>this.updateObjectAABB.call(this,object))\r\n            object.on('rotate',()=>this.updateObjectAABB.call(this,object))\r\n            this.objects.push(object)\r\n\r\n    }\r\n    \r\n    \r\n    updateObjectAABB(object){\r\n        \r\n        const oldAABB = object.BVlink.aabb\r\n      \r\n        const newAABB = object.getAABB()\r\n        \r\n        if(newAABB[0].x < oldAABB[0].x || newAABB[1].x > oldAABB[1].x ||\r\n             newAABB[0].y < oldAABB[0].y || newAABB[1].y> oldAABB[1].y ||\r\n             newAABB[0].z < oldAABB[0].z || newAABB[1].z > oldAABB[1].z)\r\n        {\r\n           this.bvh.removeLeaf(object.BVlink)\r\n           const leaf = this.bvh.insertLeaf(newAABB,object)\r\n           object.BVlink = leaf\r\n        }\r\n    }\r\n    removeObject(object){\r\n        this.bvh.removeLeaf(object.BVlink)\r\n        this.objects = this.objects.filter(el => el === object)\r\n    }\r\n    updateCollisions(){\r\n        const manifolds = this.collisionManifolds.values()\r\n        for(let manifold of manifolds){\r\n            \r\n            let i, j , n\r\n            const contacts = manifold.contacts\r\n            const pos1 = manifold.body1.collider.pos\r\n            const pos2 = manifold.body2.collider.pos\r\n            for(i = 0, j = 0, n = contacts.length; i < n; i++){\r\n                const contact = contacts[i]\r\n                const newPA = pos1.add(contact.ra)\r\n                const newPB = pos2.add(contact.rb)\r\n                const raBias = contact.PA.substract(newPA)\r\n                const rbBias = contact.PB.substract(newPB)\r\n                if(raBias.norm() < prec + manifold.warm * 0.001  && rbBias.norm() <  prec +manifold.warm * 0.001){\r\n                    contacts[j] = contacts[i]\r\n                   j++\r\n                }\r\n                \r\n            }\r\n            \r\n            while(j < contacts.length){\r\n                contacts.pop()\r\n            }\r\n            \r\n            if(contacts.length < 4&& manifold.warm  > 1) manifold.warm--\r\n            if(contacts.length === 4 && manifold.warm < 5)manifold.warm ++\r\n            if(contacts.length > 4){\r\n                let deepest = null\r\n                let maxDeep = 0\r\n                for(i = 0, n = contacts.length; i < n; i++){\r\n                    if(contacts[i].n.normSq() >= maxDeep){\r\n                        maxDeep = contacts[i].n.normSq()\r\n                        deepest = contacts[i]\r\n                    }\r\n                }\r\n                let furthest = null\r\n                let maxDistance = 0\r\n                for(i = 0, n = contacts.length; i < n; i++){\r\n                    let dist = contacts[i].PA.substract(deepest.PA).normSq()\r\n                    if(dist >= maxDistance){\r\n                        maxDistance = dist\r\n                        furthest = contacts[i]\r\n                    }\r\n                }\r\n                let furthest2 = null\r\n                maxDistance = 0\r\n                for(i = 0, n = contacts.length; i < n; i++){\r\n                    let dist = distanceFromLine(furthest.PA, deepest.PA, contacts[i].PA)\r\n                    \r\n                    if(dist >= maxDistance){\r\n                        maxDistance = dist\r\n                        furthest2 = contacts[i]\r\n                    }\r\n                }\r\n                \r\n                let furthest3 = null\r\n                maxDistance = 0\r\n               \r\n                const oppositeTodiagonal = findLargestFace(deepest.PA,furthest.PA,furthest2.PA)\r\n                \r\n                for(i = 0, n = contacts.length; i < n; i++){\r\n                    let dist = oppositeTodiagonal.substract(contacts[i].PA).normSq()\r\n                    \r\n                    if(dist >= maxDistance){\r\n                        maxDistance = dist\r\n                        furthest3 = contacts[i]\r\n                    }\r\n                }\r\n               \r\n\r\n                contacts[0] = deepest\r\n                contacts[1] = furthest\r\n                contacts[2] = furthest2\r\n                contacts[3] = furthest3\r\n                while(contacts.length > 4) contacts.pop()\r\n                \r\n            }\r\n            \r\n\r\n        }\r\n        for(let i = 0, n = this.objects.length; i < n; i++){\r\n            const object = this.objects[i]\r\n            if(object.static) continue\r\n            const cols = this.bvh.getCollisions(object.BVlink)\r\n            object.BVlink.isChecked = true\r\n            \r\n            for(let j = 0, n = cols.length; j < n; j++){\r\n                const hash = pairHash(object.id, cols[j].id)\r\n                let manifold = this.collisionManifolds.get(hash)\r\n                if(manifold && manifold.contacts.length > 4) continue\r\n                const contact = gjk(object, cols[j])\r\n                if(!contact) continue\r\n                \r\n                \r\n                if(!manifold){\r\n                    manifold = { contacts : [], body1 : object, body2 : cols[j], warm : 0}\r\n                    this.collisionManifolds.set(hash,manifold)\r\n                }\r\n                let isFarEnough = true\r\n                const contacts = manifold.contacts\r\n                for(let i = 0, n = contacts.length; i < n; i++){\r\n                    const biasPA = contacts[i].PA.substract(contact.PA)\r\n                    const biasPB = contacts[i].PB.substract(contact.PB)\r\n                    if(biasPA.norm() < prec || biasPB.norm() < prec) isFarEnough = false \r\n                }\r\n                if(isFarEnough) contacts.push(contact)   \r\n            }\r\n        }\r\n        \r\n        this.bvh.setUnchecked()\r\n        \r\n    }\r\n    tick(deltaTime){\r\n        \r\n        for(let i = 0, n = this.objects.length;i < n; i++){\r\n            this.objects[i].update(deltaTime)\r\n        }   \r\n        this.updateCollisions()\r\n        \r\n        this.cols = []\r\n        let manifolds = this.collisionManifolds.values()\r\n        \r\n        \r\n        \r\n       \r\n            for(let manifold of manifolds){\r\n                const contacts = manifold.contacts\r\n                \r\n                /*if(contacts.length > 0){\r\n                    const deepest = contacts[0]\r\n                    manifold.body1.translate(...deepest.n.multiply(-1/manifold.body1.mass).toArray())\r\n                    manifold.body2.translate(...deepest.n.multiply(1/manifold.body2.mass).toArray())\r\n                }   */\r\n\r\n\r\n                if(manifold.warm > 1){\r\n                    warmStart(manifold, deltaTime)\r\n                   \r\n                }   \r\n                getCollisionResolution(manifold, deltaTime) \r\n                \r\n                \r\n                \r\n            \r\n        }\r\n        \r\n    }\r\n}\r\n\r\nmodule.exports = {Simulation}","\r\n\r\nconst {Vector} = require('./vectors')\r\nconst getBoundAabb = (aabb1, aabb2)=>{\r\n    if(!aabb1 || !aabb2){\r\n        return 0\r\n    }\r\n    const x1 = aabb1[0].x < aabb2[0].x ? aabb1[0].x : aabb2[0].x\r\n    const x2 = aabb1[1].x > aabb2[1].x ? aabb1[1].x : aabb2[1].x\r\n    const y1 = aabb1[0].y < aabb2[0].y ? aabb1[0].y : aabb2[0].y\r\n    const y2 = aabb1[1].y > aabb2[1].y ? aabb1[1].y : aabb2[1].y\r\n    const z1 = aabb1[0].z < aabb2[0].z ? aabb1[0].z : aabb2[0].z\r\n    const z2 = aabb1[1].z > aabb2[1].z ? aabb1[1].z : aabb2[1].z\r\n    return [new Vector(x1 , y1,z1), new Vector(x2, y2, z2)]\r\n}\r\nconst isCollide = (aabb1,aabb2) => {\r\n      \r\n    if(aabb1[0].x <= aabb2[1].x && aabb1[1].x >= aabb2[0].x && aabb1[0].y <= aabb2[1].y && aabb1[1].y >= aabb2[0].y && aabb1[0].z <= aabb2[1].z && aabb1[1].z >= aabb2[0].z){\r\n        return true\r\n    }\r\n    return false\r\n}\r\nconst getSize = (aabb) => {\r\n    const area = Math.abs(aabb[1].x - aabb[0].x) + Math.abs(aabb[1].y - aabb[0].y) + Math.abs(aabb[1].z - aabb[0].z)\r\n    return area > 0 ? area : - area\r\n}\r\nclass Node{\r\n    constructor(aabb,isLeaf,gameObject){\r\n        this.aabb = aabb\r\n        this.isLeaf = isLeaf\r\n        this.parent = null\r\n        \r\n        this.gameObject = gameObject\r\n        this.isChecked = false\r\n    }\r\n}\r\nclass Tree{\r\n    constructor(){\r\n        \r\n        this.root = null\r\n        this.leafs = {}\r\n        this.unusedIndexes = []\r\n        \r\n    }\r\n    setUnchecked(){\r\n        const stack = [this.root]\r\n        \r\n        while(stack.length != 0){\r\n            const node = stack.pop()\r\n            if(node.isLeaf) {\r\n                node.isChecked = false\r\n                continue\r\n            }\r\n            if(node.child1) stack.push(node.child1)\r\n            if(node.child2) stack.push(node.child2)\r\n\r\n        }\r\n    }\r\n    getBestSibling(leaf){\r\n        let potential = this.root\r\n        while(!potential.isLeaf){\r\n            const size = getSize(potential.aabb)\r\n            const combinedAABB = getBoundAabb(potential.aabb, leaf.aabb)\r\n            const combinedSize = getSize(combinedAABB)\r\n            let cost = combinedSize\r\n            let inherCost = combinedSize - size\r\n\r\n            let cost1\r\n            if( potential.child1.isLeaf){\r\n                cost1 = getSize(potential.child1.aabb) + inherCost\r\n            }\r\n            else{\r\n                cost1 = getSize(getBoundAabb(leaf.aabb, potential.child1.aabb)) - getSize(potential.child1.aabb) + inherCost\r\n            }\r\n\r\n            let cost2\r\n            if(potential.child2.isLeaf){\r\n                cost2 = getSize(potential.child2.aabb) + inherCost\r\n            }\r\n            else{\r\n                cost2 = getSize(getBoundAabb(leaf.aabb, potential.child2.aabb)) - getSize(potential.child2.aabb) + inherCost\r\n            }\r\n            if(cost < cost1 && cost <  cost2) return potential\r\n            if(cost1 < cost2){\r\n                potential = potential.child1\r\n            }\r\n            else potential = potential.child2\r\n        }\r\n        return potential\r\n    }\r\n    insertLeaf(aabb,gameObject){\r\n        \r\n        const leaf = new Node(aabb,true,gameObject)\r\n        if(this.root === null){\r\n            this.root = leaf\r\n            this.root.parent = null\r\n            return leaf\r\n        }\r\n        \r\n        const sibling = this.getBestSibling(leaf)\r\n        const oldParent = sibling.parent\r\n        const newParent = new Node(leaf.aabb,false)\r\n        newParent.parent = oldParent\r\n        \r\n        newParent.aabb = getBoundAabb(leaf.aabb, sibling.aabb)\r\n        \r\n        if(oldParent){\r\n            if(oldParent.child1 === sibling) oldParent.child1 = newParent\r\n            else oldParent.child2 = newParent\r\n\r\n            newParent.child1 = sibling\r\n            newParent.child2 = leaf\r\n\r\n            sibling.parent = newParent\r\n            leaf.parent = newParent\r\n        }\r\n        else{\r\n            newParent.child1 = sibling\r\n            newParent.child2 = leaf\r\n\r\n            sibling.parent = newParent\r\n            leaf.parent = newParent\r\n            this.root = newParent\r\n        }\r\n        let index = leaf.parent\r\n        \r\n        while(index){\r\n            index = this.rebalance(index)\r\n            index = index.parent\r\n        }\r\n        return leaf\r\n    }\r\n    getCollisions(leaf){\r\n        \r\n        const cols = []\r\n        const iter = _node =>{\r\n            if(!_node){\r\n                return\r\n            }\r\n            if(_node === leaf){\r\n                return\r\n            }\r\n            if(isCollide(leaf.aabb,_node.aabb)){  \r\n                if(_node.isLeaf && !_node.isChecked){\r\n                    cols.push(_node.gameObject)\r\n                }\r\n                iter(_node.child1)\r\n                iter(_node.child2)\r\n            }\r\n        }\r\n        \r\n            iter(this.root)\r\n        \r\n        return cols\r\n    }\r\n    removeLeaf(leaf){\r\n        \r\n        if(leaf === this.root){\r\n            this.root = null\r\n            return\r\n        }\r\n        const parent = leaf.parent\r\n        const grandParent = parent ? parent.parent : null \r\n        let sibling\r\n        if(parent.child1 === leaf) sibling = parent.child2\r\n        else sibling = parent.child1\r\n\r\n        if(grandParent){\r\n            if(grandParent.child1 === parent) grandParent.child1 = sibling\r\n            else grandParent.child2 = sibling\r\n\r\n            sibling.parent = grandParent\r\n\r\n            let index = grandParent\r\n            while(index){\r\n                index = this.rebalance(index)\r\n\r\n                index = index.parent\r\n            }\r\n        }\r\n        else {\r\n            this.root = sibling\r\n            sibling.parent = null\r\n        }\r\n    }\r\n    rebalance(leaf){\r\n        if(!leaf){\r\n            return null\r\n        }\r\n        if(leaf.isLeaf || this.getHeight(leaf) < 2){\r\n            leaf.aabb = getBoundAabb(leaf.child1.aabb, leaf.child2.aabb)\r\n            return leaf\r\n        }\r\n        const child1 = leaf.child1\r\n        const child2 = leaf.child2\r\n        const balance = this.getHeight(child2) - this.getHeight(child1)\r\n        \r\n        if(balance > 1){\r\n            const child2Child1 = child2.child1\r\n            const child2Child2 = child2.child2\r\n\r\n            child2.child1 = leaf\r\n            child2.parent = leaf.parent\r\n            leaf.parent = child2\r\n            if(child2.parent != null){\r\n                if(child2.parent.child1 === leaf){\r\n                    child2.parent.child1 = child2\r\n                }\r\n                else{\r\n                    child2.parent.child2 = child2\r\n                }\r\n            }\r\n            else this.root = child2\r\n            if(this.getHeight(child2Child1) > this.getHeight(child2Child2)){\r\n                child2.child2 = child2Child1\r\n                leaf.child2 = child2Child2\r\n                child2Child2.parent = leaf\r\n                \r\n            }\r\n            else{\r\n                \r\n                leaf.child2 = child2Child1\r\n                child2Child1.parent = leaf\r\n            }\r\n            leaf.aabb = getBoundAabb(leaf.child1.aabb, leaf.child2.aabb)\r\n            child2.aabb = getBoundAabb(child2.child1.aabb, child2.child2.aabb)\r\n           \r\n            return child2\r\n            \r\n        }\r\n        if(balance < -1){\r\n            const child1Child1 = child1.child1\r\n            const child1Child2 = child1.child2\r\n            \r\n            child1.child1 = leaf\r\n            child1.parent = leaf.parent\r\n            leaf.parent = child1\r\n\r\n            if(child1.parent != null){\r\n                if(child1.parent.child1 === leaf){\r\n                    child1.parent.child1 = child1\r\n                }\r\n                else{\r\n                    child1.parent.child2 = child1\r\n                }\r\n            }\r\n            else this.root = child1\r\n            if(this.getHeight(child1Child1) > this.getHeight(child1Child2)){\r\n                child1.child2 = child1Child1\r\n                leaf.child1 = child1Child2\r\n                child1Child2.parent = leaf\r\n                \r\n            }\r\n            else{\r\n                child1.child2 = child1Child2\r\n                leaf.child1 = child1Child1\r\n                child1Child1.parent = leaf\r\n            }\r\n            leaf.aabb = getBoundAabb(leaf.child1.aabb, leaf.child2.aabb)\r\n            child1.aabb = getBoundAabb(child1.child1.aabb, child1.child2.aabb)\r\n            \r\n            return child1\r\n        }\r\n       leaf.aabb = getBoundAabb(leaf.child1.aabb, leaf.child2.aabb)\r\n       return leaf\r\n    }\r\n    toArray(i){\r\n        const iter = (leaf, level)  =>{\r\n            if(!leaf){\r\n                return null\r\n                \r\n            }\r\n            if(leaf.isLeaf) return leaf.objectLink.name\r\n            else return [iter(leaf.child1), iter(leaf.child2)]\r\n        }\r\n        if(!i) i = this.root\r\n        return iter(i)\r\n    }\r\n    getHeight(leaf){\r\n        \r\n        const iter = (leaf, level)  =>{\r\n            if(!leaf){\r\n                return level\r\n                \r\n            }\r\n            \r\n            let h1 = iter(leaf.child1, level + 1)\r\n            let h2 = iter(leaf.child2, level + 1)\r\n            return h1 > h2 ? h1 : h2\r\n        }\r\n        return iter(leaf,1)\r\n    }\r\n    \r\n}\r\nmodule.exports = {Tree, Node}","\r\n\r\nfunction Vector(x = 0, y = 0, z = 0){\r\n\r\n    \r\n    this.x = x\r\n    this.y = y\r\n    this.z = z\r\n}\r\n\r\nVector.prototype.toArray = function(){\r\n    return [this.x,this.y,this.z]\r\n}\r\nconst dot = (v1,v2) => v1.x * v2.x + v1.y * v2.y + v1.z * v2.z\r\n\r\nconst cross = (v1,v2) => new Vector(\r\n                        v1.y * v2.z - v2.y * v1.z,\r\n                        v1.z * v2.x - v2.z * v1.x,\r\n                        v1.x * v2.y - v2.x * v1.y )\r\nVector.prototype.add = function(v){\r\n    return new Vector(this.x + v.x, this.y + v.y, this.z + v.z)\r\n}\r\nVector.prototype.multiply = function(a){\r\n    return new Vector(this.x * a, this.y * a, this.z * a)\r\n\r\n}\r\n\r\nVector.prototype.substract = function(v){\r\n    return new Vector(this.x - v.x, this.y - v.y, this.z - v.z)\r\n}\r\nVector.prototype.isNull = function(){\r\n    return this.x * this.x + this.y * this.y + this.z * this.z === 0\r\n}\r\nconst normalize = v =>{\r\n    const len = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z)\r\n    return new Vector(v.x / len, v.y / len, v.z / len)\r\n}\r\nVector.prototype.norm = function(){\r\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)\r\n}\r\nVector.prototype.normSq = function(){\r\n    return this.x * this.x + this.y * this.y + this.z * this.z\r\n}\r\nconst distanceFromLine = (a,b,c) =>{\r\n    const ac = c.substract(a)\r\n    const ab = b.substract(a)\r\n    const k = dot(ab,ac) / ab.normSq()\r\n    const h = a.add(ab.multiply(k))\r\n    return c.substract(h).normSq()\r\n}\r\nconst distanceFromTriangle = (a,b,c,d) =>{\r\n    const h1 = distanceFromLine(a,b,d)\r\n    const h2 = distanceFromLine(a,c,d)\r\n    const h3 = distanceFromLine(b,c,d)\r\n    if(h1 < h2){\r\n        if(h1 < h3) return h1\r\n        return h3\r\n    }\r\n    else{\r\n        if(h2 < h3) return h2\r\n        else return h3\r\n    }\r\n}\r\n\r\nconst findLargestFace = (a,b,c) => {\r\n    const AB = a.substract(b).normSq()\r\n    const AC = a.substract(c).normSq()\r\n    const BC = c.substract(b).normSq()\r\n    if(AB < AC){\r\n        if(AB < BC) return c\r\n        return b\r\n    }\r\n    else{\r\n        if(AC < BC) return b\r\n        else return a\r\n    }\r\n}\r\nmodule.exports = {Vector, cross, dot, normalize, distanceFromLine, distanceFromTriangle, findLargestFace}"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}